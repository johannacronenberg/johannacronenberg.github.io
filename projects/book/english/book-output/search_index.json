[["index.html", "Programming in R: An Introduction for Phoneticians 1 Setup 1.1 Installation 1.2 R Projects 1.3 Packages and R Version 1.4 Sessions 1.5 Types of Documents 1.6 Help", " Programming in R: An Introduction for Phoneticians Johanna Cronenberg 2024-03-14 1 Setup 1.1 Installation Download and install the Software R. The latest version is currently 4.3.x (March 2024). Also download and install RStudio. Watch this short introduction to RStudio. Create a directory on your hard drive to be used for this course. 1.2 R Projects This course will make use of an R project which will make working with R easier in the long run. Open RStudio and click on the (very small) triangle in the top right hand corner labelled Project: (None). Then click on New Project and then Existing Directory and use Browse to select the directory that you just created on your hard drive. Finish by clicking on Create Project. RStudio will then automatically open this project that has the same name as your course directory (see the triangle on the top right). The project can be closed via this triangle and also re-opened. The project can also be opened by clicking on the file that has been created in your course directory with the extension .Rproj. If you have any difficulty with project installation watch this introductory video. More information on R projects R projects have many advantages especially if R is being used in several courses and there is a separate R project for each course. The project remembers which files were displayed and makes these available when the project is opened again – so that you can carry on working where you left off. Moreover, the working directory of the project is your course directory. As a result, all files that you put into this directory are accessible via the Files toolbar on the bottom right. You can also check what your course directory is by entering getwd() into the console and hitting enter. 1.3 Packages and R Version There are many thousands of packages i.e. libraries which make working in R easier. Please install the following (takes a few minutes): install.packages(c(&quot;Rcpp&quot;, &quot;remotes&quot;, &quot;knitr&quot;, &quot;tidyverse&quot;, &quot;magrittr&quot;, &quot;rmarkdown&quot;, &quot;emuR&quot;, &quot;gridExtra&quot;, &quot;emmeans&quot;, &quot;broom&quot;, &quot;lmerTest&quot;, &quot;pbkrtest&quot;, &quot;MuMIn&quot;)) More information: Installation of R packages Should the above result in the error message installation of package had non-zero exit status, then it means that the installation failed. For Windows, you might then additionally have to install Rtools. For MacOS you might need to install/reset the XCode command-line tools. For this purpose, open a Mac terminal window and execute the following: xcode-select --install # Should the R packages installation still not work: xcode-select --reset If you are unsure about how to solve problems during the installation of R packages, please ask me! While some base packages are automatically loaded when you start up RStudio, most have to be loaded using the library() function, thus: library(tidyverse) library(emuR) Further Information: Updates Please check regularly whether your packages need to be updated – updates in R are not automatic! For this purpose, click in the main toolbar on Tools &gt; Check for Package Updates. You can also check whether there are any updates to RStudio via Help &gt; Check for Updates. R also has to be regularly updated. Check what version you have with getRversion(). Check the R Webpage regularly to see whether a newer, stable version is available. 1.4 Sessions A session starts when either R or RStudio or a project is opened. A session is terminated with Session &gt; Quit Session in the main toolbar or with Strg+Q or Ctrl+Q or q(). The session also ends automatically when you quit RStudio. You will then be asked whether you want to save the workspace image. Should you want to keep the objects that you have created in any one session so that they are available again in the next session, click save. The workspace is then saved in your course directory with the extension .RData. If you don’t want to save the workspace, click Don't save. If you decide you don’t want to end the session after all, click Cancel. For this course, please never save the workspace i.e. Don't save. 1.5 Types of Documents 1.5.1 R Scripts The console in RStudio is the direct connection to R i.e. that’s where R code can be executed. But storing R code in a document is important in order to be able to replicate previously executed code. You could do this with an R script which can be created with File &gt; New File &gt; R Script (or via Strg + Shift + N) and should always be saved with a .R extension. An R script only contains executable code. When an R script is run, all lines are executed except those that begin with # that are commented out. There are various ways of executing an R script. Select the required lines of code (or if it’s just one line of code, put the cursor on the line) and then click Run or enter Strg + enter or Ctrl + enter. The output from running the command is then immediately visible in the console. 1.5.2 R Markdown In the last few years R Markdown has become another popular way for creating documents for R code that can be especially useful for creating reports and teaching material. R Markdown is a document containing snippets of R code that can then be executed in the way described above. R Markdown documents often have more text than code. You can create an R Markdown document with File &gt; New File &gt; R Markdown in the main toolbar. It’s conventional to save the document with the extension .Rmd. An R markdown file is usually converted or knitted into a different format such as HTML or PDF or even Word. This is done via the button with a ball of wool marked Knit or via: library(rmarkdown) render(&quot;document.Rmd&quot;) R Markdown was also used to create the HTML document that you are currently reading. Special symbols are used in the markdown document that are converted as follows when knitted: # Heading: A hashtag gives the largest heading size; the more hashtags used, the smaller the size of the heading. **bold**: A double asterisk before and after the text marks it as bold. *italics*: A single asterisk italicises text. `code`: The backslash quotes highlight the text: this is often used when marking code or variables outside of a code snippet (but note that any such code cannot be executed). ```: Three backslash quotes in sequence mark the beginning and the end of a code snippet (also known as a code block). All R code must be entered between the sets of three backslash quotes; any text inside a snippet has to be marked with a # in order for it to be identified as a comment. Curly brackets identify the language in which the code is written (for our purposes: {r}). More information is available in the cheatsheet for R Markdown (esp. page 2, left column). 1.6 Help 1.6.1 Recognising Errors Warnings: if you make a syntax error (e.g. by forgetting a bracket), you will see a red warning sign at the beginning of the line of code that contains the error. Don’t ignore this because it shows that a mistake has been made. The warning sign disappears once the error is corrected. “Knit”: We recommend that you regularly convert your Markdown document to HTML by clicking Knit on the toolbar at the top. If all goes well, you will hopefully see the compiled HTML in a new window or in the viewer. However, if you have syntax errors or other errors in your code, the HTML will not be generated and you will instead get an error in the console where you can also see in which line the error has occurred. Execute code one line (or in blocks of a couple of lines) at a time. That way you can see the result and decide whether this is what you intended. 1.6.2 Ask the Community There is a very large and helpful R community that will make learning R easier for you. Here are a few useful links and commands in case you get stuck: Stack Overflow: A blog where you can often find an answer to your questions about R. The easiest way is to google your question in English; a stack overflow member’s answer will be included in the first search results. Hadley Wickham’s “R for Data Science”: Hadley Wickham is the chief programmer of the “tidyverse”. His books are very readable, well structured, and entertaining. Cheatsheets: those are PDFs that provide an overview of functions with explanations and examples in a very compact form. You will find some cheatsheets in the main toolbar via Help &gt; Cheatsheets. The first three are especially useful. You can also find cheatsheets by googling, see e.g. Data Transformation with dplyr or this very comprehensive Reference Card. Vignettes: For some packages there are so-called “vignettes”, which are mostly HTMLs or PDFs that have been written by the package’s authors. You can search for vignettes using the following input to the console: # for e.g. one of the libraries from tidyverse vignette(&quot;dplyr&quot;) You can get information about a function by entering its name in the RStudio Help tab on the bottom right. You’ll then get information about the function’s arguments and often some examples. You can also get help via the console, as follows (e.g. here for getwd()): ?getwd help(&quot;getwd&quot;) 1.6.3 Help with ggplot2 ggplot2 is both well-known and popular and there’s plenty of help available for ggplot2 from the R community. Here are some useful links for creating graphics: The chapter Data Visualisation in Hadley Wickham’s “R for Data Science” Cookbook for R Cheatsheet ggplot2 Stack Overflow 1.6.4 Statistics in R: Literature If you need more information about using statistics in R, the following are recommended: Bodo Winter’s “Statistics for Linguists: An Introduction using R”: A recent book with excellent explanations to all major themes in inferential statistics. It’s available online via the LMU library. Stefan Gries’ “Statistics for Linguistics with R: A Practical Introduction”: Useful for decision making about which model to use for which type of question. Although the code is not always up-to-date (given that the book was published in 2009) the statistical content is still valid. Also online via the LMU library. Harald Baayen’s “Analyzing Linguistic Data: A Practical Introduction to Statistics”: This is for more advanced readers. Although the R code is a bit out of date, the explanations and examples of statistics foundations are very helpful. Available as a hard copy from the LMU library. "],["first-calculations-in-r.html", "2 First Calculations in R 2.1 Variables &amp; Functions 2.2 Object Classes 2.3 Vectors 2.4 Arithmetic and Logical Operators 2.5 Manipulate Vectors 2.6 Factors", " 2 First Calculations in R On the bottom left of RStudio you can find the Console. This is where code is executed, i.e. the console is the direct connection between R and the computer. For instance, enter the following code line by line into the console and hit enter after every line: 1 + 1 ## [1] 2 10 - 5 ## [1] 5 3 * 4 ## [1] 12 12 / 6 ## [1] 2 2^4 ## [1] 16 The answers to the entered calculations is returned in the console. 2.1 Variables &amp; Functions Of course we won’t just use the console as a calculator. Often we want to use certain values repeatedly without having to re-enter the calculation every time. That is why we save values as so called variables. These variables can be found in the environment, i.e. the panel on the top right. In order to create a new variable, you have to enter the desired variable name followed by the arrow &lt;- followed by the value. Here we create a variable called sum which contains the value 1 + 1: sum &lt;- 1 + 1 To see the contents of the variable, simply enter the variable’s name in the console and hit enter again: sum ## [1] 2 You can see, that the variable doesn’t return 1 + 1, but 2. Whenever we want to use the value of the calculation 1 + 1, we can use sum instead: sum + 3 ## [1] 5 Caution! Variables are overwritten in R without any warning: x &lt;- 4 x ## [1] 4 x &lt;- 3 x ## [1] 3 In your R environment are two variables now: sum has the value 2, x has the value 3. You can find out which variables are in your environment by using a so called function. Functions (also: commands) execute actions. These actions were defined as code which was written by someone and made available for all users of R (you can also write functions yourself, but that won’t be covered in this course). Enter the following command into your console and hit the enter: ls() ## [1] &quot;githubs&quot; &quot;sum&quot; &quot;x&quot; The function is called ls(), which stands for list, and returns the names of all variables in your environment. You can recognise functions because they are followed by brackets. The arguments of the function, i.e. any information or values needed by the function to do its job, are given within these brackets. ls() is one of the few functions in R which do not need any arguments. Another useful function is rm() (remove), which removes variables from the environment (careful: this decision is permanent!). This function takes as arguments the names of the variables which shall be deleted. Here we are deleting the variable x: rm(x) ls() ## [1] &quot;githubs&quot; &quot;sum&quot; 2.2 Object Classes So far we have only handled numbers (so called numerics). There are quite a few more types of objects in R. For starters, the numeric objects can be doubles or integers. x &lt;- 3.2 # double x ## [1] 3.2 y &lt;- 4 # integer y ## [1] 4 Additionally, there are strings or characters which must always be enclosed by quotes: z &lt;- &quot;hello world!&quot; z ## [1] &quot;hello world!&quot; … as well as the two boolean values (aka logicals) which are written in caps: a &lt;- TRUE # Shorthand: T a ## [1] TRUE b &lt;- FALSE # Shorthand: F b ## [1] FALSE Furthermore, there is another important class of objects called factor which is used for categorical data. This type of data, together with a few more object classes, will be introduced in more detail later. In order to find out the class of a variable, use the function class(). This function only has one argument – the name of the variable: class(a) ## [1] &quot;logical&quot; class(y) ## [1] &quot;numeric&quot; class(z) ## [1] &quot;character&quot; 2.3 Vectors The function c() (concatenate) creates a vector, i.e. a data structure that contains elements of the same class. vec &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # all elements are strings vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; vec &lt;- c(3, 6, 89.3, 0, -10) # all elements are numerics (more precisely: doubles) vec ## [1] 3.0 6.0 89.3 0.0 -10.0 If the elements are of different classes (strings, booleans, numerics), the elements are silently (i.e. without warning) converted into the same type. c(3, 4, &quot;string&quot;, T) # all elements are converted into strings ## [1] &quot;3&quot; &quot;4&quot; &quot;string&quot; &quot;TRUE&quot; c(2, 5, T, F) # all elements are converted into numerics; TRUE = 1, FALSE = 0 ## [1] 2 5 1 0 2.4 Arithmetic and Logical Operators You have already experienced that the console works as a calculator. The basic arithmetic operations as well as arithmetic functions can be applied to all numeric objects as well as to numeric vectors: a &lt;- c(10, 4, 20) a * 10 ## [1] 100 40 200 b &lt;- c(5, 2, 7) a + b ## [1] 15 6 27 R provides many arithmetic functions which only receive a numeric variable as argument: sum(a) # sum of all elements ## [1] 34 sqrt(a) # square root of each element ## [1] 3.162 2.000 4.472 log(a) # logarithm of each element ## [1] 2.303 1.386 2.996 exp(a) # exponential of each element ## [1] 2.203e+04 5.460e+01 4.852e+08 Logical operators compare two variables of the same class. The following logical operators exist in R: x &lt; y # less than x &gt; y # more than x &lt;= y # less than or equal x &gt;= y # more than or equal x == y # exactly equal x != y # unequal !x # not x x | y # x OR y x &amp; y # x AND y isTRUE(x) # test if x is TRUE x %in% y # test if a value x is contained in a vector y Expressions which use these operators return the boolean values, either TRUE or FALSE, as you can see in the following examples: x &lt;- 3 y &lt;- 4 x == y ## [1] FALSE x != y ## [1] TRUE x &gt; y ## [1] FALSE x &lt;- c(1, 2, 3, 4, 5) x == 3 ## [1] FALSE FALSE TRUE FALSE FALSE &quot;a&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## [1] TRUE The logical operators will become very important in later chapters. 2.5 Manipulate Vectors We want to introduce a few more functions that can be helpful in working with vectors. Besides c() there are other functions that create vectors. First of all, there is a shorthand for vectors of sequential integers, by using the colon: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 The function seq() creates a vector of numeric intervals, i.e. sequences of numbers which are equally spaced. The function has three arguments: the first (from) and the maximal (not necessarily last) value of the interval (to), and then either the desired length of the vector (length.out) or the steps of the interval (by). seq(from = 10, to = 20, length.out = 5) # 5 intervals between 10 and 20 ## [1] 10.0 12.5 15.0 17.5 20.0 seq(from = 10, to = 20, by = 1.5) # in intervals of 1.5 ## [1] 10.0 11.5 13.0 14.5 16.0 17.5 19.0 Further Information: arguments in functions Above you are shown for the first time, that arguments in functions have names (e.g. from, to, length.out and by). When arguments have names (which is almost always the case), you can either use the names as shown above or leave them out. seq(10, 20, length.out = 5) ## [1] 10.0 12.5 15.0 17.5 20.0 If you do not use the arguments’ names, you have to submit the necessary values to the function in the right order. The order of the function’s arguments can be found on the help pages. Navigate to the tab Help on the bottom right and enter the function name seq in the search bar. When you hit enter you should see the help page of that function. As you can see, the order of the arguments is from, to, and then either by or length.out. We can omit the argument names from and to as long as we use the right values in the right order, i.e. first the value intended as from, then the one for to. However, the function does not know whether the third argument is supposed to be by or length.out, hence we write the argument as length.out = 5. If we did not mention the argument’s name here, the function would interpret the number 5 as the argument by: seq(10, 20, 5) ## [1] 10 15 20 If we use the arguments’ names, the order does not matter: seq(to = 20, by = 1.5, from = 10) ## [1] 10.0 11.5 13.0 14.5 16.0 17.5 19.0 The function rep() repeats values (no matter if numeric, logical, or strings). Besides the values that are to be repeated, the function has the arguments times and/or each (or the argument length.out which we ignore for now). Here we demonstrate what these arguments do (also consult the help page of that function!): rep(1, times = 3) ## [1] 1 1 1 rep(&quot;a&quot;, times = 2) ## [1] &quot;a&quot; &quot;a&quot; vek &lt;- c(&quot;a&quot;, &quot;b&quot;) rep(vek, times = 4) ## [1] &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; rep(vek, each = 4) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; rep(vek, times = 3, each = 3) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; ## [13] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; Lastly, there are two related functions that generate vectors of strings: paste() and paste0(). The function paste() takes all elements that are to be connected, and optionally the argument sep (separator) that determines which symbol connects the elements. paste0() only takes the elements. When the elements are all simple strings, paste() and paste0() generate a string, whereas when one element is a vector, the result is a vector of strings. paste(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot; &quot;) ## [1] &quot;a b c&quot; paste(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;&quot;) ## [1] &quot;abc&quot; paste0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## [1] &quot;abc&quot; paste(&quot;subject&quot;, 1:5, sep = &quot;_&quot;) ## [1] &quot;subject_1&quot; &quot;subject_2&quot; &quot;subject_3&quot; &quot;subject_4&quot; ## [5] &quot;subject_5&quot; paste0(&quot;subject&quot;, 1:5) ## [1] &quot;subject1&quot; &quot;subject2&quot; &quot;subject3&quot; &quot;subject4&quot; ## [5] &quot;subject5&quot; There are a few more useful functions that manipulate vectors or give you information about the contents of vectors. Look at your R environment. There are three simple variables now: sum, y, and z. All other variables are vectors. For instance, you can see that the variable a is a numeric vector of length 3 (i.e. it contains 3 elements): it says num [1:3]. num means numeric, the notation [1:3] indicates that the vector is a one-dimensional object of length 3. To query the length of a vector without having to look at the environment, use the function length(): length(a) ## [1] 3 length(vec) ## [1] 5 If you want to know which unique elements are in a vector, use unique(): vec &lt;- c(1, 5, 2, 7, 6, 3, 7, 5) unique(vec) ## [1] 1 5 2 7 6 3 vec &lt;- c(&quot;i&quot;, &quot;i&quot;, &quot;a&quot;, &quot;a&quot;, &quot;E&quot;, &quot;E&quot;, &quot;E&quot;, &quot;E&quot;, &quot;U&quot;) unique(vec) ## [1] &quot;i&quot; &quot;a&quot; &quot;E&quot; &quot;U&quot; Finally we want to introduce a very versatile function called table(). When this function is applied to a vector, it returns the unique elements of the vector including how often they appear in the vector: table(vec) ## vec ## a E i U ## 2 4 2 1 So in vec, there are two occurrences of the element “a”, four of the element “E”, etc. We will see later what else table() can be used for. 2.6 Factors Now that you know about vectors, we’ll introduce the object class called factor. Factors are used for categorical data, i.e. for those that can take a limited amount of diverse values. A factor can be created using the function factor(). Here we generate a factor of different age categories: age &lt;- factor(c(&quot;young&quot;, &quot;old&quot;, &quot;old&quot;, &quot;mid&quot;, &quot;young&quot;, &quot;young&quot;)) class(age) ## [1] &quot;factor&quot; age ## [1] young old old mid young young ## Levels: mid old young When the factor age is returned in the console, you first get the values in the entered order. Even though the values were strings, they are not returned as such (i.e. in quotes). This is because they are not just strings anymore, but categories. These categories are also called levels, which are also shown in the console. The levels can be queried with the function levels(): levels(age) ## [1] &quot;mid&quot; &quot;old&quot; &quot;young&quot; The function factor() can take an argument called levels with which you can determine the levels and their order yourself (otherwise, R puts the levels in alpha-numerical order). age &lt;- factor(c(&quot;young&quot;, &quot;old&quot;, &quot;old&quot;, &quot;mid&quot;, &quot;young&quot;, &quot;young&quot;), levels = c(&quot;young&quot;, &quot;mid&quot;, &quot;old&quot;)) age ## [1] young old old mid young young ## Levels: young mid old Numeric values are rarely categorical. But if, say, you asked five classmates what their age was and saved the values in a vector: age &lt;- c(22, 25, 23, 22, 23) … and you considered the age in years as categorical, you could transform the vector into a factor. age &lt;- factor(c(22, 25, 23, 22, 23)) age ## [1] 22 25 23 22 23 ## Levels: 22 23 25 "],["data-frames.html", "3 Data Frames 3.1 Import &amp; Export 3.2 Characteristics 3.3 Accessing Columns", " 3 Data Frames A very important data structure in R is the data frame which is a two-dimensional table. The rows are also called observations, while the columns are called variables (which should not be confused with the variables, i.e. saved values or objects, from the previous chapter!). In phonetics, we often work with data frames, e.g. when we have extracted acoustic information from speech recordings or measures from a perception experiment and want to analyse those (statistically). 3.1 Import &amp; Export There are several ways of importing a .csv or .txt table in R. If you want to load a table from your hard drive, you can use the Import Dataset assistant shown in the toolbar right above the R environment on the top right. The command used by the assistant to import the data frame will be shown in the console. In this course you will use data frames that are provided on a website, which is why we have to write our own command to load them. The command we’ll use is read.table() and its main argument is the path (i.e. the URL in this case) to the data frame (but check the help page of this function for further information on its arguments and further import functions): ai &lt;- read.table(&quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf/ai.txt&quot;) Since we will use several data frames from the same website throughout this course, we can optimise our import function so that we don’t have to type or copy &amp; paste the same complicated URL every time. To do so, we store the URL as a variable of the string type and then use the function file.path() with which the URL and file name are concatenated: url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; file.path(url, &quot;ai.txt&quot;) ## [1] &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf/ai.txt&quot; # with the import command: ai &lt;- read.table(file.path(url, &quot;ai.txt&quot;)) The counterpart to read.table() is write.table() which is used to save a data frame from R to your hard drive. This function takes the name of the object in R which is to be saved and then the path including the desired file name (./ signals the current directory). In addition, we’ll use the optional argument row.names = FALSE so that the function does not add a column for the (in this case, non-existent) row names in the stored table. write.table(ai, file.path(&quot;./&quot;, &quot;ai.txt&quot;), row.names = FALSE) Of course you cannot just load data frames, you can also write them yourself using the function data.frame(). This function takes as arguments the column names and the values to fill these columns. Here is an example: df &lt;- data.frame(F1 = c(240, 220, 250, 210, 280, 520, 510, 605, 670, 613), vowel = rep(c(&quot;i&quot;,&quot;o&quot;), each = 5)) df ## F1 vowel ## 1 240 i ## 2 220 i ## 3 250 i ## 4 210 i ## 5 280 i ## 6 520 o ## 7 510 o ## 8 605 o ## 9 670 o ## 10 613 o Data frames have their own object class: class(df) ## [1] &quot;data.frame&quot; 3.2 Characteristics When we work with data structures that contain a lot of information, it is important to make yourself familiar with that object. R provides many useful functions to look at data frames or gather information about their characteristics: # look at data frame in separate panel View(ai) # return first or last observations head(ai) ## F1 Kiefer Lippe ## 1 773 -25.48 -24.60 ## 2 287 -27.03 -26.44 ## 3 1006 -27.25 -27.59 ## 4 814 -26.06 -27.17 ## 5 814 -26.15 -25.93 ## 6 806 -26.37 -24.45 tail(ai) ## F1 Kiefer Lippe ## 20 888 -25.99 -26.85 ## 21 988 -26.27 -28.27 ## 22 650 -26.50 -24.31 ## 23 1026 -27.10 -24.64 ## 24 992 -28.41 -28.31 ## 25 896 -26.57 -25.69 # number of rows and/or columns nrow(ai) ## [1] 25 ncol(ai) ## [1] 3 dim(ai) ## [1] 25 3 # column names colnames(ai) ## [1] &quot;F1&quot; &quot;Kiefer&quot; &quot;Lippe&quot; names(ai) ## [1] &quot;F1&quot; &quot;Kiefer&quot; &quot;Lippe&quot; 3.3 Accessing Columns Although we will work with the modern tidyverse syntax in the following chapters, we want to introduce briefly how to access columns of data frames in a traditional way because this can sometimes be the most efficient way. Take a look at your R environment: you’ll see that the simple variables and vectors are listed under “Values” while the two data frames ai and df are listed under “Data”. The environment also shows the number of observations and variables for each data frame, e.g. 25 obs. of 3 variables. When you click on the tiny blue icon next to the data frame’s name, it opens an overview of the column names, their object class (int for integers, num for numerics, etc.) as well as the first few values in that column. The same information can be obtained by applying the function str() (structure) to the data frame: str(ai) ## &#39;data.frame&#39;: 25 obs. of 3 variables: ## $ F1 : int 773 287 1006 814 814 806 938 1005 964 931 ... ## $ Kiefer: num -25.5 -27 -27.2 -26.1 -26.2 ... ## $ Lippe : num -24.6 -26.4 -27.6 -27.2 -25.9 ... str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ F1 : num 240 220 250 210 280 520 510 605 670 613 ## $ vowel: chr &quot;i&quot; &quot;i&quot; &quot;i&quot; &quot;i&quot; ... In front of every column in this overview you see the dollar sign. This is actually how you can access columns in data frames: type the data frame’s name, then (without spaces!) the dollar sign, then (again without spaces!) the column name: df$F1 ## [1] 240 220 250 210 280 520 510 605 670 613 You can see here that a column is basically a vector! And that means that you can now apply the functions, which we have previously used to manipulate vectors, to the columns in data frames: length(df$F1) ## [1] 10 table(df$vowel) ## ## i o ## 5 5 Further Information: Factors in Data Frames In the R environment you can see that the column vowel of the data frame df which we created above is a factor, and that this factor has two levels – even though we had filled the column vowel with a vector of strings, and not with a factor! The function data.frame() that generated df has an argument called stringsAsFactors which is set to TRUE by default. That means that the strings in the column vowels were automatically converted into a factor when the data frame was created. The two distinct values (categories) in this column are “i” and “o”, so the factor has two levels. When you take another look at the data frame df you’ll also see that the column vowel is not just a factor with two levels, but that the first values in this column are weirdly numbers, and not “i” or “o”. This is because factors are stored as integers in the background (i.e. usually invisible to users of R). These integers are associated with the levels of the factor. So when the environment lists the value 1 in the column vowel of df, it represents the level “i”, while the value 2 represents the level “o”. If you want to prevent strings from being converted into factors, you can simply set stringsAsFactors = FALSE: df &lt;- data.frame(F1 = c(240, 220, 250, 210, 280, 520, 510, 605, 670, 613), vowel = rep(c(&quot;i&quot;,&quot;o&quot;), each = 5), stringsAsFactors = FALSE) "],["introduction-to-the-tidyverse.html", "4 Introduction to the tidyverse 4.1 Pipes 4.2 Manipulating Data with dplyr 4.3 More Examples of Complex Pipes", " 4 Introduction to the tidyverse For this chapter you will need the following packages and data frames: library(tidyverse) ## ── Attaching core tidyverse packages ────────────────── ## ✔ dplyr 1.1.4 ✔ readr 2.1.5 ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ ggplot2 3.5.0 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.1 ## ✔ purrr 1.0.2 ## ── Conflicts ───────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) Please use the methods from chapter @ref{characteristics} to familiarise yourself with the three data frames! The tidyverse is a collection of packages that help with the diverse aspects of data processing. We will work with a subset of these packages in this and the following chapters. When you load the tidyverse you’ll see the following output: The tidyverse, version 2.0, consists of the listed nine packages (dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, tidyr). Each of them can also be loaded separately. Additionally, the output above shows two conflicts. The notation dplyr::filter() translates to “the function filter() from the package dplyr”. This function overwrites the function filter() from the package stats (which is one of the packages that is available upon starting RStudio, i.e. without having to load it using library()). Functions from distinct packages can overwrite each other when they have the same function name, e.g. filter(). If you were to use filter() in your code now, you would be using the function from dplyr and not the one from stats. If you explicitly want to use the function from stats, just use the notation shown above, i.e. stats::filter(). Many functions of the tidyverse replace traditional R notations which are often less easy to read and write than tidyverse code. We will use the tidyverse to clean up data frames, filter or manipulate them. 4.1 Pipes First, we have to learn the tidyverse syntax: asp %&gt;% head() ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un ## 3 26.81 Montag k01 t un ## 4 14.75 Vater k01 t un ## 5 42.38 Tisch k01 t be ## 6 21.56 Mutter k01 t un We begin each snippet of code with the data frame and then just add the functions that we want to apply to the data frame in chronological order. Between each function you put the pipe symbol %&gt;% the pipe always takes the object on its left-hand side and submits it to the function on its right-hand side. So in this code snippet above, the function head() is applied to the data frame asp. This has exactly the same effect as: head(asp) ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un ## 3 26.81 Montag k01 t un ## 4 14.75 Vater k01 t un ## 5 42.38 Tisch k01 t be ## 6 21.56 Mutter k01 t un Using the simple pipe in a snippet of tidyverse code, the data frame is not changed. The result of the code is simply printed in the console. If, however, you want to save the result of a tidyverse pipe in a variable you can use the usual notation with the arrow &lt;-: numberOfRows &lt;- asp %&gt;% nrow() numberOfRows ## [1] 2892 The special thing is that you can attach as many functions to a pipe as you want. The functions will then always be applied to the result from the previous function, as we will see soon. Within a function you can access the columns of the data frame by means of their name, without using any special symbols or notations. 4.2 Manipulating Data with dplyr The most important functions which you will need in your day-to-day usage of R are part of the package dplyr. We differentiate here between different kinds of operations that you can apply to data frames using dplyr functions. 4.2.1 Filtering A common task is filtering or selecting certain rows and/or columns. You can choose certain rows by means of the function filter(). The argument(s) of that function is/are one or more logical expressions using the logical operators from chapter 2.4. If you want to select all rows of the data frame asp for which the string “Montag” is in the column Wort, you can use the operator ==: asp %&gt;% filter(Wort == &quot;Montag&quot;) ## d Wort Vpn Kons Bet ## 3 26.81 Montag k01 t un ## 63 17.75 Montag k01 t un ## 123 45.12 Montag k02 t un ## 182 40.50 Montag k03 t un ## 241 33.00 Montag k04 t un ## 300 32.69 Montag k04 t un ## 359 50.82 Montag k05 t un ## 476 27.93 Montag k06 t un ## 537 17.25 Montag k61 t un ## 597 21.13 Montag k62 t un ## 656 20.75 Montag k62 t un ## 2078 105.94 Montag k70 t un ## 2079 17.56 Montag k70 t un ## 2080 22.25 Montag k70 t un ## 2155 60.25 Montag K19 t un ## 2156 14.87 Montag K20 t un ## 2157 17.56 Montag K20 t un ## 2231 47.31 Montag K74 t un ## 2232 34.94 Montag K74 t un ## 2233 35.44 Montag K74 t un ## 2310 22.62 Montag k61 t un ## 2311 16.43 Montag k61 t un ## 2312 29.31 Montag k61 t un ## 2391 50.31 Montag k61 t un ## 2392 33.12 Montag k61 t un ## 2393 39.68 Montag k61 t un ## 2403 42.88 Montag k61 t un ## 2424 35.44 Montag k62 t un ## 2506 11.25 Montag k62 t un ## 2528 8.06 Montag k62 t un ## 2604 33.94 Montag dlm t un ## 2624 29.87 Montag dlm t un ## 2704 30.32 Montag dlm t un ## 2725 21.93 Montag dlm t un ## 2800 49.12 Montag hpt t un ## 2821 24.87 Montag hpt t un All rows for which the duration d is lower than 10 ms is given by the following expression: asp %&gt;% filter(d &lt; 10) ## d Wort Vpn Kons Bet ## 180 9.130 Fruehlingswetter k03 t un ## 205 8.440 verstauchter k03 t un ## 540 6.688 Mutter k61 t un ## 773 8.000 Butter k64 t un ## 895 7.060 Buttergeschichte k66 t un ## 982 9.500 Butter k66 t un ## 999 8.300 Butter K22 t un ## 1142 9.750 Vater K30 t un ## 1155 8.630 Schwester K61 t un ## 1170 5.690 maechtig K62 t un ## 1294 9.690 Butter k07 t un ## 1362 8.870 Freitag k08 t un ## 1548 6.500 Vater k10 t un ## 1564 8.750 spaeter k11 t un ## 1565 5.250 Sonntags k11 t un ## 2507 6.570 unterbrechen k62 t un ## 2528 8.060 Montag k62 t un ## 2542 9.500 Samstag k62 t un ## 2580 8.880 samstags k62 t un Of course you can connect several logical expressions using the logical operators for “and” &amp; or for “or” |. The following expression, for instance, only returns rows for which the participant Vpn is either “k01” or “k02” or “k03” and the consonant Kons is not “t”: asp %&gt;% filter(Vpn %in% c(&quot;k01&quot;, &quot;k02&quot;, &quot;k03&quot;) &amp; Kons != &quot;t&quot;) ## d Wort Vpn Kons Bet ## 7 50.00 konnte k01 k un ## 8 78.12 Kaffee k01 k be ## 11 64.13 Broetchenkorb k01 k be ## 12 48.94 keinen k01 k be ## 13 59.00 Kuchen k01 k be ## 16 56.00 einkaufen k01 k be ## 19 34.37 Zucker k01 k un ## 20 55.75 Suessigkeiten k01 k un ## 21 55.62 kaufen k01 k be ## 22 55.94 Konserven k01 k un ## 23 61.81 Kasse k01 k be ## 28 47.25 Kartoffeln k01 k un ## 31 37.62 Kaffee k01 k be ## 33 54.19 Koennen k01 k un ## 35 35.49 Dickicht k01 k un ## 40 59.44 Kuechenofen k01 k be ## 42 64.50 kocht k01 k be ## 48 69.19 Karten k01 k be ## 49 58.69 Fahrkarten k01 k be ## 53 30.82 Acker k01 k un ## 57 95.13 kurz k01 k be ## 58 57.38 verkuendet k01 k be ## 59 72.00 kommen k01 k be ## 67 37.75 konnte k01 k un ## 68 52.69 Kaffee k01 k be ## 71 71.43 Broetchenkorb k01 k be ## 72 51.75 keinen k02 k be ## 73 70.82 Kuchen k02 k be ## 76 68.19 einkaufen k02 k be ## 79 17.38 Zucker k02 k un ## 80 50.25 Suessigkeiten k02 k un ## 81 43.07 kaufen k02 k be ## 82 35.62 Konserven k02 k un ## 83 59.25 Kasse k02 k be ## 88 44.94 Kartoffeln k02 k un ## 91 34.44 Kaffee k02 k be ## 93 35.62 Koennen k02 k un ## 95 30.69 Dickicht k02 k un ## 100 72.32 Kuechenofen k02 k be ## 102 33.75 kocht k02 k be ## 108 61.06 Karten k02 k be ## 109 50.82 Fahrkarten k02 k be ## 113 23.93 Acker k02 k un ## 117 67.87 kurz k02 k be ## 118 35.62 verkuendet k02 k be ## 119 44.56 kommen k02 k be ## 127 39.87 konnte k02 k un ## 128 46.00 Kaffee k02 k be ## 131 67.57 Broetchenkorb k02 k be ## 132 58.25 keinen k02 k be ## 133 58.81 Kuchen k02 k be ## 136 54.94 einkaufen k02 k be ## 139 30.88 Zucker k02 k un ## 140 49.18 Suessigkeiten k02 k un ## 141 63.44 kaufen k02 k be ## 142 45.25 Konserven k02 k un ## 143 50.50 Kasse k02 k be ## 148 54.31 Kartoffeln k03 k un ## 151 53.25 Kaffee k03 k be ## 153 34.00 Koennen k03 k un ## 155 47.82 Dickicht k03 k un ## 160 50.56 Kuechenofen k03 k be ## 162 38.38 kocht k03 k be ## 168 62.43 Karten k03 k be ## 169 36.94 Fahrkarten k03 k be ## 172 46.69 Acker k03 k un ## 176 43.38 kurz k03 k be ## 177 54.75 verkuendet k03 k be ## 178 53.75 kommen k03 k be ## 186 32.56 konnte k03 k un ## 187 41.81 Kaffee k03 k be ## 190 56.81 Broetchenkorb k03 k be ## 191 52.93 keinen k03 k be ## 192 59.88 Kuchen k03 k be ## 195 46.13 einkaufen k03 k be ## 198 29.51 Zucker k03 k un ## 199 43.13 Suessigkeiten k03 k un ## 200 36.75 kaufen k03 k be ## 201 33.82 Konserven k03 k un ## 202 60.69 Kasse k03 k be ## 206 32.25 Kartoffeln k03 k un ## 209 48.00 Kaffee k03 k be ## 211 33.19 Koennen k03 k un ## 213 56.81 Dickicht k03 k un ## 218 65.37 Kuechenofen k03 k be ## 220 40.81 kocht k03 k be The rows in a data frame are usually numbered, i.e. all rows have an index. If you want to select rows by their index, use slice() or the related functions slice_head(), slice_tail(), slice_min() and slice_max(). The function slice() takes the index of the rows to be selected as its only argument: asp %&gt;% slice(4) # select row 4 ## d Wort Vpn Kons Bet ## 4 14.75 Vater k01 t un asp %&gt;% slice(1:10) # select the first 10 rows ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un ## 3 26.81 Montag k01 t un ## 4 14.75 Vater k01 t un ## 5 42.38 Tisch k01 t be ## 6 21.56 Mutter k01 t un ## 7 50.00 konnte k01 k un ## 8 78.12 Kaffee k01 k be ## 9 53.63 Tassen k01 t be ## 10 45.94 Teller k01 t be The functions slice_head() and slice_tail() have an argument n which is the amount of rows starting with the first or last, respectively, that are to be selected. asp %&gt;% slice_head(n = 2) # select the first two rows ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un asp %&gt;% slice_tail(n = 3) # select the last three rows ## d Wort Vpn Kons Bet ## 2890 24.94 vormittags kko t un ## 2891 21.93 Richtung kko t un ## 2892 51.94 Verkehrt kko k be The functions slice_min() and slice_max() return the n rows that have the lowest, respectively highest, values in a given column. If n is not provided by the user, the function automatically uses n = 1, i.e. only one row is returned. Further Information: Defaults for arguments If you do not specify certain arguments in functions, often the default values will be used. For an example, look at the help page of the function seq(). This tells you the following information about this function and its arguments: The arguments from and to have the default value 1. And since these are the only obligatory arguments in that case, you can actually execute the function without giving it any arguments explicitly: seq() ## [1] 1 The argument by also has a default value that is calculated from the values of to, from and length.out unless the user supplies the argument. Often you can find the defaults for arguments on the help pages under Usage, sometimes they are only provided in the description of the arguments below that. Here are two examples for the two functions which refer to the duration in column d of the data frame asp. asp %&gt;% slice_min(d) # choose the row where d has the lowest value ## d Wort Vpn Kons Bet ## 1565 5.25 Sonntags k11 t un asp %&gt;% slice_min(d, n = 5) # choose the five rows where d has the lowest values ## d Wort Vpn Kons Bet ## 1565 5.250 Sonntags k11 t un ## 1170 5.690 maechtig K62 t un ## 1548 6.500 Vater k10 t un ## 2507 6.570 unterbrechen k62 t un ## 540 6.688 Mutter k61 t un asp %&gt;% slice_max(d) # choose the row where d has the highest value ## d Wort Vpn Kons Bet ## 2063 138.8 Kiel k70 k be asp %&gt;% slice_max(d, n = 5) # choose the five rows where d has the highest values ## d Wort Vpn Kons Bet ## 2063 138.8 Kiel k70 k be ## 2843 129.7 Kiel hpt k be ## 1006 116.5 Ladentuer K23 t be ## 2070 111.6 Tagen k70 t be ## 1456 111.4 kauen k09 k be These two functions can even be applied to columns that contain strings. In this case the selection is done alphabetically. asp %&gt;% slice_min(Wort) # choose the row where Wort has the &quot;lowest&quot; value ## d Wort Vpn Kons Bet ## 51 47.63 Abteil k01 t be ## 111 56.25 Abteil k02 t be ## 171 56.81 Abteil k03 t be ## 229 31.63 Abteil k04 t be ## 288 67.31 Abteil k04 t be ## 347 76.25 Abteil k05 t be ## 406 38.07 Abteil k05 t be ## 463 52.62 Abteil k06 t be ## 524 46.93 Abteil k61 t be ## 585 35.18 Abteil k61 t be ## 644 47.00 Abteil k62 t be ## 703 79.37 Abteil k63 t be asp %&gt;% slice_max(Wort) # choose the row where Wort has the &quot;highest&quot; value ## d Wort Vpn Kons Bet ## 2444 80.75 zurueckkommen k62 k be ## 2546 73.44 zurueckkommen k62 k be ## 2641 53.30 zurueckkommen dlm k be ## 2743 63.12 zurueckkommen dlm k be ## 2838 79.63 zurueckkommen hpt k be Since there are several rows for which the column Wort has the lowest (“abkaufen”) respectively highest value (“Zwischenstop”), all of these rows are returned despite n = 1. 4.2.2 Selecting The function for selecting columns is called select() which can be used in several ways. The only arguments to the function are the names of the columns to be selected. In the following examples you’ll also see for the first time how to concatenate several functions, because we’ll limit the output of the select() function by adding slice(1) for pure visual reasons. asp %&gt;% select(Vpn) %&gt;% slice(1) # only column Vpn ## Vpn ## 1 k01 asp %&gt;% select(Vpn, Bet) %&gt;% slice(1) # columns Vpn and Bet ## Vpn Bet ## 1 k01 un asp %&gt;% select(d:Kons) %&gt;% slice(1) # columns d until Kons ## d Wort Vpn Kons ## 1 26.18 Fruehlingswetter k01 t asp %&gt;% select(!(d:Kons)) %&gt;% slice(1) # all columns except those between d and Kons ## Bet ## 1 un asp %&gt;% select(-Wort) %&gt;% slice(1) # all columns except Wort ## d Vpn Kons Bet ## 1 26.18 k01 t un Within the function select() it can be helpful to use the functions starts_with() and ends_with(), if you want to select all columns whose name starts or ends with the same letter(s). We’ll demonstrate this using the data frame vdata which has the following columns: vdata %&gt;% colnames() ## [1] &quot;X&quot; &quot;Y&quot; &quot;F1&quot; &quot;F2&quot; &quot;dur&quot; &quot;V&quot; ## [7] &quot;Tense&quot; &quot;Cons&quot; &quot;Rate&quot; &quot;Subj&quot; starts_with() allows us to select F1 and F2 because both start with “F”: vdata %&gt;% select(starts_with(&quot;F&quot;)) %&gt;% slice(1) ## F1 F2 ## 1 313 966 Similarly to what you have learnt about filtering, you can connect the functions starts_with() and ends_with() using the logical operators &amp; and |. Here we select the column “F1” (admittedly in a pretty laborious way): vdata %&gt;% select(starts_with(&quot;F&quot;) &amp; !ends_with(&quot;2&quot;)) %&gt;% slice(1) ## F1 ## 1 313 Sometimes we do not want our tidyverse pipes to return a column in the form of a data frame, but as a simple vector. This can be done with pull(). In the following pipe, we first choose the first ten rows of asp and then want to return the column Bet as a vector: asp %&gt;% slice(1:10) %&gt;% pull(Bet) ## [1] &quot;un&quot; &quot;un&quot; &quot;un&quot; &quot;un&quot; &quot;be&quot; &quot;un&quot; &quot;un&quot; &quot;be&quot; &quot;be&quot; &quot;be&quot; In the output you see that Bet was indeed returned as a vector. 4.2.3 Mutating Mutating here means to add or change columns in data frames. The command to do that is called mutate() and takes as arguments the new columns and the values to fill the columns. When you want to add several new columns you can do so in the same mutate() command. The following code, for instance, adds two new columns called F1 and F2 to the data frame int: int %&gt;% head() ## Vpn dB Dauer ## 1 S1 24.50 162 ## 2 S2 32.54 120 ## 3 S2 38.02 223 ## 4 S2 28.38 131 ## 5 S1 23.47 67 ## 6 S2 37.82 169 int %&gt;% mutate(F1 = c(282, 277, 228, 270, 313, 293, 289, 380, 293, 307, 238, 359, 300, 318, 231), F2 = c(470, 516, 496, 530, 566, 465, 495, 577, 501, 579, 562, 542, 604, 491, 577)) ## Vpn dB Dauer F1 F2 ## 1 S1 24.50 162 282 470 ## 2 S2 32.54 120 277 516 ## 3 S2 38.02 223 228 496 ## 4 S2 28.38 131 270 530 ## 5 S1 23.47 67 313 566 ## 6 S2 37.82 169 293 465 ## 7 S2 30.08 81 289 495 ## 8 S1 24.50 192 380 577 ## 9 S1 21.37 116 293 501 ## 10 S2 25.60 55 307 579 ## 11 S1 40.20 252 238 562 ## 12 S1 44.27 232 359 542 ## 13 S1 26.60 144 300 604 ## 14 S1 20.88 103 318 491 ## 15 S2 26.05 212 231 577 These new columns are not automatically saved in the data frame! There are two ways to attach new columns to a data frame permanently. The first is as usually with the arrow &lt;-. Let’s create a new variable int_new that contains the data frame int including the two new columns (we also could have overwritten the original data frame int with the mutated data frame by calling the variable int). int_new &lt;- int %&gt;% mutate(F1 = c(282, 277, 228, 270, 313, 293, 289, 380, 293, 307, 238, 359, 300, 318, 231), F2 = c(470, 516, 496, 530, 566, 465, 495, 577, 501, 579, 562, 542, 604, 491, 577)) int_new %&gt;% head() ## Vpn dB Dauer F1 F2 ## 1 S1 24.50 162 282 470 ## 2 S2 32.54 120 277 516 ## 3 S2 38.02 223 228 496 ## 4 S2 28.38 131 270 530 ## 5 S1 23.47 67 313 566 ## 6 S2 37.82 169 293 465 The second way is the so-called double pipe from the package magrittr: %&lt;&gt;%. The double pipe can only be the first pipe in a line of pipes (as we shall see soon). Furthermore you only need to put the data frame to be overwritten to the left of the double pipe, not again on the right. int %&lt;&gt;% mutate(F1 = c(282, 277, 228, 270, 313, 293, 289, 380, 293, 307, 238, 359, 300, 318, 231), F2 = c(470, 516, 496, 530, 566, 465, 495, 577, 501, 579, 562, 542, 604, 491, 577)) int %&gt;% head() ## Vpn dB Dauer F1 F2 ## 1 S1 24.50 162 282 470 ## 2 S2 32.54 120 277 516 ## 3 S2 38.02 223 228 496 ## 4 S2 28.38 131 270 530 ## 5 S1 23.47 67 313 566 ## 6 S2 37.82 169 293 465 There are two functions that are very useful within mutate() if the values of a new column are dependent on those of existing columns. For binary decisions you can use ifelse(), otherwise case_when(). Let’s assume you want to attach another column to the data frame int. You know that participant “S1” is 29 years old, whereas participant “S2” is 33 years old. You want to add a column age with that information. In that case, you should use ifelse() within mutate(). ifelse() takes as arguments a logical expression, then the value for rows for which that expression evaluates to TRUE, and lastly the value for rows for which the expression is FALSE. When you execute this command, it is tested for every row whether the participant is “S1”, if so, it puts the value 29 in the new column age, otherwise it puts the value 33. int %&gt;% mutate(age = ifelse(Vpn == &quot;S1&quot;, 29, 33)) ## Vpn dB Dauer F1 F2 age ## 1 S1 24.50 162 282 470 29 ## 2 S2 32.54 120 277 516 33 ## 3 S2 38.02 223 228 496 33 ## 4 S2 28.38 131 270 530 33 ## 5 S1 23.47 67 313 566 29 ## 6 S2 37.82 169 293 465 33 ## 7 S2 30.08 81 289 495 33 ## 8 S1 24.50 192 380 577 29 ## 9 S1 21.37 116 293 501 29 ## 10 S2 25.60 55 307 579 33 ## 11 S1 40.20 252 238 562 29 ## 12 S1 44.27 232 359 542 29 ## 13 S1 26.60 144 300 604 29 ## 14 S1 20.88 103 318 491 29 ## 15 S2 26.05 212 231 577 33 When this kind of decision is non-binary, you can use the function case_when(). This function takes as many logical expressions and corresponding values as desired. We’ll add another new column to the data frame int which will be called noise. When the column dB has a value of below 25 decibels, the column noise should have the value “quiet”, for noise levels between 25 and 35 it should say “mid”, and for values above 35 decibels it should say “loud”. The notation of these conditions is as follows: First the logical expression, then a tilde ~, and finally the value to be written into the new column if the logical expression is TRUE. int %&gt;% mutate(noise = case_when(dB &lt; 25 ~ &quot;quiet&quot;, dB &gt; 25 &amp; dB &lt; 35 ~ &quot;mid&quot;, dB &gt; 35 ~ &quot;loud&quot;)) ## Vpn dB Dauer F1 F2 noise ## 1 S1 24.50 162 282 470 quiet ## 2 S2 32.54 120 277 516 mid ## 3 S2 38.02 223 228 496 loud ## 4 S2 28.38 131 270 530 mid ## 5 S1 23.47 67 313 566 quiet ## 6 S2 37.82 169 293 465 loud ## 7 S2 30.08 81 289 495 mid ## 8 S1 24.50 192 380 577 quiet ## 9 S1 21.37 116 293 501 quiet ## 10 S2 25.60 55 307 579 mid ## 11 S1 40.20 252 238 562 loud ## 12 S1 44.27 232 359 542 loud ## 13 S1 26.60 144 300 604 mid ## 14 S1 20.88 103 318 491 quiet ## 15 S2 26.05 212 231 577 mid 4.2.4 Renaming Columns should always be given reasonable names, i.e. names that tell you exactly and concisely what the content of the column is – this is not a trivial demand!). In the data frame asp almost all column names are abbreviations: asp %&gt;% colnames() ## [1] &quot;d&quot; &quot;Wort&quot; &quot;Vpn&quot; &quot;Kons&quot; &quot;Bet&quot; Using the function rename() we’ll rename all the columns and save the result directly in asp using the double pipe. The arguments of that function are the desired column name, then =, and then the old column name. You do not need to put the column names in quotes. You can also rename several columns at once. asp %&lt;&gt;% rename(duration = d, subject = Vpn, consonant = Kons, stress = Bet) asp %&gt;% colnames() ## [1] &quot;duration&quot; &quot;Wort&quot; &quot;subject&quot; &quot;consonant&quot; ## [5] &quot;stress&quot; 4.3 More Examples of Complex Pipes As you have seen already, you can concatenate multiple functions using pipes. While doing that, it is very important to consider that each function is applied to the result of the previous function. If you write long pipes (i.e. several functions connected via %&gt;%), you should always add a line break right after the %&gt;% for reasons of legibility. The following two pipes have the same result and do not throw any error, but they progress differently. In the first example, the column subject is selected before the first row is returned, in the second example the steps are reversed. asp %&gt;% select(subject) %&gt;% slice(1) ## subject ## 1 k01 asp %&gt;% slice(1) %&gt;% select(subject) ## subject ## 1 k01 Such pipes can occasionally lead to errors if you do not decide carefully which functions to execute first. For instance, let’s say you want to select the column X from the data frame vdata but you also want to rename it to age. The following code is going to throw an error because the function select() can not be applied to a column X after that column has been renamed to age: vdata %&gt;% rename(age = X) %&gt;% select(X) ## Error in `select()`: ## ! Can&#39;t subset columns that don&#39;t exist. ## ✖ Column `X` doesn&#39;t exist. This error also tells you exactly what went wrong. The correct order of functions is this (we also use slice(1:10) to reduce the visible output): vdata %&gt;% select(X) %&gt;% rename(age = X) %&gt;% slice(1:10) ## age ## 1 52.99 ## 2 53.61 ## 3 55.14 ## 4 53.06 ## 5 52.74 ## 6 53.30 ## 7 54.37 ## 8 51.20 ## 9 54.65 ## 10 58.42 Another example: you want to be given the duration values (Dauer) in int for F1 values below 270 Hz. int %&gt;% pull(Dauer) %&gt;% filter(F1 &lt; 270) ## Error in UseMethod(&quot;filter&quot;): no applicable method for &#39;filter&#39; applied to an object of class &quot;c(&#39;integer&#39;, &#39;numeric&#39;)&quot; This error is much more cryptic. Let’s reconstruct what went wrong. We pulled the column Dauer from the data frame int, and that column does exist. However, we used pull() for that operation, which returns the column as a vector, and not as a data frame. You can test this as follows: int %&gt;% pull(Dauer) ## [1] 162 120 223 131 67 169 81 192 116 55 252 232 ## [13] 144 103 212 int %&gt;% pull(Dauer) %&gt;% class() ## [1] &quot;integer&quot; Yes, this is a vector of integers. In the code above, we then tried to apply a function to that vector that is meant to be applied to data frames only – that’s why the pipe threw an error. The solution in this case is to filter first, and then pull the duration values: int %&gt;% filter(F1 &lt; 270) %&gt;% pull(Dauer) ## [1] 223 252 212 These are the duration values for the three rows for which F1 is lower than 270 Hz. Finally, we want to show an example of a complex pipe using the double pipe at the beginning. So what we do here will overwrite the data frame, and not just print the result in the console. We want to add the column noise to the data frame int permanently now, then select all rows for which the subject is “S1” and the duration is between 100 and 200 ms, and lastly we want to select the columns noise and Dauer as well as the first five rows. int %&lt;&gt;% mutate(noise = case_when(dB &lt; 25 ~ &quot;quiet&quot;, dB &gt; 25 &amp; dB &lt; 35 ~ &quot;mid&quot;, dB &gt; 35 ~ &quot;loud&quot;)) %&gt;% filter(Vpn == &quot;S1&quot; &amp; Dauer &gt; 100 &amp; Dauer &lt; 200) %&gt;% select(Dauer, noise) %&gt;% slice_head(n = 5) int ## Dauer noise ## 1 162 quiet ## 8 192 quiet ## 9 116 quiet ## 13 144 mid ## 14 103 quiet The data frame int now only consists of two columns and five rows and this operation can not be undone. So please be careful and think about whether or not you want to overwrite a data frame with the result of a pipe. "],["summary-statistics.html", "5 Summary Statistics 5.1 Mean &amp; Median 5.2 Variance &amp; Standard Deviation 5.3 Quantiles 5.4 Example of a Boxplot", " 5 Summary Statistics Please load the following packages and data frame for this chapter: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) When you want to get an overview of some data, it is helpful to compute so called summary statistics (sometimes called descriptive statistics). Among others, these are the arithmetic mean, median, variance, standard deviation, minimum, maximum, etc. Here we aim to show you how these values can be computed without using functions from the tidyverse. Since R is a statistics software, functions to compute summary statistics are always available. The following code snippet presents the most important functions from base R for descriptive statistics, applied to the F1 values in vdata: mean(vdata$F1) # arithmetic mean ## [1] 407.3 median(vdata$F1) # median ## [1] 366 var(vdata$F1) # variance ## [1] 21255 sd(vdata$F1) # standard deviation ## [1] 145.8 min(vdata$F1) # minimum ## [1] 0 max(vdata$F1) # maximum ## [1] 1114 range(vdata$F1) # minimum &amp; maximum ## [1] 0 1114 quantile(vdata$F1, 0.25) # first quartile ## 25% ## 300 quantile(vdata$F1, 0.75) # third quartile ## 75% ## 509.8 IQR(vdata$F1) # interquartile range ## [1] 209.8 5.1 Mean &amp; Median The arithmetic mean is calculated by summing \\(n\\) numbers and then dividing this sum by \\(n\\). Here is a very simple example: nums &lt;- 1:5 s &lt;- sum(nums) s ## [1] 15 count &lt;- length(nums) count ## [1] 5 # mean: s/count ## [1] 3 # for comparison: mean(nums) ## [1] 3 The median on the other hand is the middle number in a sorted sequence of numbers. Let’s reuse the above example (in which the numbers are already in ascending order): nums ## [1] 1 2 3 4 5 median(nums) ## [1] 3 For an even number of numbers the median is the mean of the two middle values, e.g.: nums &lt;- 1:6 median(nums) ## [1] 3.5 mean(c(3, 4)) ## [1] 3.5 The median is more robust against outliers than the mean. Outliers are data points that are more extreme then the majority of data points in a data set. Here is another simple example: nums &lt;- c(1:5, 100) nums ## [1] 1 2 3 4 5 100 mean(nums) ## [1] 19.17 median(nums) ## [1] 3.5 The number 100 is obviously an outlier in the vector called nums. Because of that, the mean is now much higher than previously, while the median has changed only slightly. 5.2 Variance &amp; Standard Deviation Variance and standard deviation are related measures for the dispersion of values around their mean. More precisely, the variance is the sum of the squared deviations of the values from their mean, divided by the number of values minus 1, while the standard deviation is the square root of the variance. The following example demonstrates how to compute the variance and standard deviation manually. nums &lt;- c(12, 6, 24, 3, 17) # mean m &lt;- mean(nums) m ## [1] 12.4 # squared differences squared_diff &lt;- (nums - m)^2 squared_diff ## [1] 0.16 40.96 134.56 88.36 21.16 # number of values n &lt;- length(nums) n ## [1] 5 # sum of the squared differences s &lt;- sum(squared_diff) s ## [1] 285.2 # variance variance &lt;- s / (n - 1) variance ## [1] 71.3 # using the function var(): var(nums) ## [1] 71.3 To compute the standard deviation from that (which is used far more often in statistics than the variance) we only need to extract the square root of the variance: std_dev &lt;- sqrt(variance) std_dev ## [1] 8.444 # using the function sd(): sd(nums) ## [1] 8.444 5.3 Quantiles A quantile divides data points in such a way that a given part of the data points is below the quantile. Quantile is a hypernym: depending on how many chunks you divide your data points into, you can also use the terms percentile (100 chunks) or quartile (4 chunks). The median is another quantile because 50% of the data are below the median. In R, the function quantile() computes quantiles. The function takes as arguments the data points (i.e. a numeric vector) and then the proportion of data points that should be below the value to be computed. Important quantiles are the first and third quartile, i.e. the thresholds below which a quarter or three quarters of all data points lie. quantile(vdata$F1, 0.25) # first quartile ## 25% ## 300 quantile(vdata$F1, 0.75) # third quartile ## 75% ## 509.8 IQR(vdata$F1) # interquartile range ## [1] 209.8 The difference between the first and third quartile is called interquartile range and can be computed with the function IQR(). 5.4 Example of a Boxplot A boxplot contains many of the descriptive information that we have learned about so far: Median: the horizontal line within the box is the median. Box: the box contains the middle 50% of the data points. The lower end of the box is the first quartile (Q1), the upper end is the third quartile (Q3). The box is as big as the interquartile range. Whiskers: the vertical lines stretching upwards/downwards from Q1 and Q3 to the highest/lowest data point that lies within 1.5 * IQR. The calculation of the whiskers as 1.5 * IQR is valid for boxplots created with ggplot2, but some other programs use a different calculation. Points: outliers, i.e. all data points that are not contained in the box or whiskers. Here you see a boxplot for F1 from the data frame vdata: Later in this course, you’ll learn how to create this boxplot yourself. "],["manipulating-data-with-dplyr-continuation.html", "6 Manipulating Data with dplyr (Continuation) 6.1 Grouping &amp; Summarising 6.2 Arranging", " 6 Manipulating Data with dplyr (Continuation) 6.1 Grouping &amp; Summarising Please load the following libraries and data frames for this chapter: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) coronal &lt;- read.table(file.path(url, &quot;coronal.txt&quot;)) vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) Chapter 5 was concerned with summary statistics regarding the F1 values stored in the data frame vdata. Of course we can calculate these values just as well using the tidyverse syntax. This is actually what the function summarise() from the package dplyr was made for. This function changes that data frame completely because the original observations are summarised to new, descriptive values. The columns of the original data are also usually dropped and new columns containing the calculated values are created. The function takes as arguments the new column names and a function with which the values for the new column shall be calculated: vdata %&gt;% summarise(arith_mean = mean(F1)) ## arith_mean ## 1 407.3 The output of this pipe is a data frame of just one column called arith_mean and one observation which contains the arithmetic mean of vdata$F1. We can also compute several summary statistics within one call of summarise(), which results in a data frame with more columns: vdata %&gt;% summarise(arith_mean = mean(F1), std_dev = sd(F1), s = sum(F1), maximum = max(F1), Q1 = quantile(F1, 0.25)) ## arith_mean std_dev s maximum Q1 ## 1 407.3 145.8 1214532 1114 300 The functions mutate() and summarise() have in common that they create new columns from the old ones. However, while mutate() keeps all original columns and observations, summarise() creates a new data frame with usually less columns and observations than before. Say, you want to compute the arithmetic mean of F1 for a specific vowel V in the data frame vdata – how would you do that? Using tidyverse, probably like this (for the vowel V == \"E\"): vdata %&gt;% filter(V == &quot;E&quot;) %&gt;% summarise(arith_mean = mean(F1)) ## arith_mean ## 1 426.2 The mean F1 for “E” is approx. 426 Hz. If you’re interested in the vowel-specific mean F1 values, it is very inefficient to rerun the code above for every single vowel category in the data frame. Instead, you can use the function group_by() which takes as arguments the names of all columns by which you want to group the result of the code. summarise() computes the desired summary statistics then per group. In our example, let’s compute the mean for each vowel: vdata %&gt;% group_by(V) %&gt;% summarise(arith_mean = mean(F1)) ## # A tibble: 7 × 2 ## V arith_mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 % 424. ## 2 A 645. ## 3 E 426. ## 4 I 311. ## 5 O 434. ## 6 U 304. ## 7 Y 302. This code created two columns: one contains the seven distinct vowel from the original data frame, the second the vowel-specific mean F1 values. Of course you can group the results by more than one column. It is, for instance, probably the case that the mean F1 is not just different for each vowel, but that the tenseness Tense of the vowel also affects F1. That is why we group now by vowel and tenseness and then compute the mean F1: vdata %&gt;% group_by(V, Tense) %&gt;% summarise(arith_mean = mean(F1)) ## `summarise()` has grouped output by &#39;V&#39;. You can ## override using the `.groups` argument. ## # A tibble: 14 × 3 ## # Groups: V [7] ## V Tense arith_mean ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 % + 368. ## 2 % - 479. ## 3 A + 668. ## 4 A - 622. ## 5 E + 363. ## 6 E - 488. ## 7 I + 276. ## 8 I - 346. ## 9 O + 348. ## 10 O - 520. ## 11 U + 259. ## 12 U - 348. ## 13 Y + 266. ## 14 Y - 338. Now we can see the mean F1 for lax “%”, tense “%” (ignore the weird vowel encoding), lax “A”, tense “A” and so on. Further Information: summarise() warning Above you can see a warning that was thrown by the summarise() command. Warnings try to get your attention – don’t ignore them! This specific warning shows that the result of the pipe is a grouped data frame (object class grouped_df) and that V is the grouping variable: vdata %&gt;% group_by(V, Tense) %&gt;% summarise(arith_mean = mean(F1)) %&gt;% class() ## `summarise()` has grouped output by &#39;V&#39;. You can ## override using the `.groups` argument. ## [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; The warning also tells you that you can the change the grouping of the results by using the function’s argument .groups. This argument can take on different values as you can read on the help page for summarise(). In the previous code snippets in which we used group_by() together with summarise() the warning didn’t show up because we grouped by only one variable; thus the grouping is removed automatically in the results. Importantly, you can only use group_by() on categorical columns, i.e. factors. It makes no sense to use grouping on non-categorical, numeric columns because there are no groups there (rather, every value in a numeric column is unique or at least rare). We, on the other hand, want to calculate summary statistics for categorical groups. Lastly we want to introduce the function n() and n_distinct(). n() takes no arguments and is used within summarise() and after group_by() to return the number of observations (rows) per group. n_distinct() takes the name of one column as an argument and finds out how many distinct (unique) values of a variable there are per group. # number of rows for every combination of V and Tense vdata %&gt;% group_by(V, Tense) %&gt;% summarise(count = n()) ## `summarise()` has grouped output by &#39;V&#39;. You can ## override using the `.groups` argument. ## # A tibble: 14 × 3 ## # Groups: V [7] ## V Tense count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 % + 212 ## 2 % - 214 ## 3 A + 214 ## 4 A - 218 ## 5 E + 210 ## 6 E - 215 ## 7 I + 210 ## 8 I - 214 ## 9 O + 214 ## 10 O - 214 ## 11 U + 208 ## 12 U - 215 ## 13 Y + 211 ## 14 Y - 213 # number of unique participants `Vpn` per region and social class coronal %&gt;% group_by(Region, Socialclass) %&gt;% summarise(count = n_distinct(Vpn)) ## `summarise()` has grouped output by &#39;Region&#39;. You can ## override using the `.groups` argument. ## # A tibble: 9 × 3 ## # Groups: Region [3] ## Region Socialclass count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 R1 LM 40 ## 2 R1 UM 30 ## 3 R1 W 11 ## 4 R2 LM 26 ## 5 R2 UM 18 ## 6 R2 W 36 ## 7 R3 LM 22 ## 8 R3 UM 31 ## 9 R3 W 26 Further Information: Describing functions unambiguously Since functions from the tidyverse, especially from dplyr, have pretty common names (filter(), summarise(), rename()), they can be masked easily by functions of the same name from other packages. So if a function returns an error message, try re-loading the package of which the function you used is a part, or use the following notation: dplyr::filter(). 6.2 Arranging In your everyday work with data frames it can be useful to arrange the data frame with regard to rows and/or columns. Use arrange() for sorting rows and relocate() for sorting columns. Here we arrange the data frame int in ascending order by duration Dauer: int %&gt;% arrange(Dauer) ## Vpn dB Dauer ## 10 S2 25.60 55 ## 5 S1 23.47 67 ## 7 S2 30.08 81 ## 14 S1 20.88 103 ## 9 S1 21.37 116 ## 2 S2 32.54 120 ## 4 S2 28.38 131 ## 13 S1 26.60 144 ## 1 S1 24.50 162 ## 6 S2 37.82 169 ## 8 S1 24.50 192 ## 15 S2 26.05 212 ## 3 S2 38.02 223 ## 12 S1 44.27 232 ## 11 S1 40.20 252 arrange() can also sort alphabetically and with regard to several columns: int %&gt;% arrange(Vpn, Dauer) ## Vpn dB Dauer ## 5 S1 23.47 67 ## 14 S1 20.88 103 ## 9 S1 21.37 116 ## 13 S1 26.60 144 ## 1 S1 24.50 162 ## 8 S1 24.50 192 ## 12 S1 44.27 232 ## 11 S1 40.20 252 ## 10 S2 25.60 55 ## 7 S2 30.08 81 ## 2 S2 32.54 120 ## 4 S2 28.38 131 ## 6 S2 37.82 169 ## 15 S2 26.05 212 ## 3 S2 38.02 223 To put a data frame in descending order, you can use desc() within arrange(): int %&gt;% arrange(Vpn, desc(Dauer)) ## Vpn dB Dauer ## 11 S1 40.20 252 ## 12 S1 44.27 232 ## 8 S1 24.50 192 ## 1 S1 24.50 162 ## 13 S1 26.60 144 ## 9 S1 21.37 116 ## 14 S1 20.88 103 ## 5 S1 23.47 67 ## 3 S2 38.02 223 ## 15 S2 26.05 212 ## 6 S2 37.82 169 ## 4 S2 28.38 131 ## 2 S2 32.54 120 ## 7 S2 30.08 81 ## 10 S2 25.60 55 relocate() takes as arguments the names of all columns that are to be relocated. If you submit no further arguments, the columns are put in first place. Otherwise you can use the arguments .before and .after to specify the new location of the columns: vdata %&gt;% slice(1) ## X Y F1 F2 dur V Tense Cons Rate Subj ## 1 52.99 4.36 313 966 106.9 % - P a bk vdata %&gt;% relocate(Subj) %&gt;% slice(1) ## Subj X Y F1 F2 dur V Tense Cons Rate ## 1 bk 52.99 4.36 313 966 106.9 % - P a vdata %&gt;% relocate(Subj, Cons) %&gt;% slice(1) ## Subj Cons X Y F1 F2 dur V Tense Rate ## 1 bk P 52.99 4.36 313 966 106.9 % - a vdata %&gt;% relocate(where(is.numeric), .after = Subj) %&gt;% slice(1) ## V Tense Cons Rate Subj X Y F1 F2 dur ## 1 % - P a bk 52.99 4.36 313 966 106.9 vdata %&gt;% relocate(where(is.character), .before = dur) %&gt;% slice(1) ## X Y F1 F2 V Tense Cons Rate Subj dur ## 1 52.99 4.36 313 966 % - P a bk 106.9 "],["plotting-data-with-ggplot2.html", "7 Plotting Data with ggplot2 7.1 Boxplots 7.2 Scatter- &amp; Lineplots 7.3 Barplots 7.4 Histograms &amp; Probability Density", " 7 Plotting Data with ggplot2 In this chapter you’ll need the following packages and data frames: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) coronal &lt;- read.table(file.path(url, &quot;coronal.txt&quot;)) vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) ggplot2 is a library from the tidyverse that gives you very many possibilities to visualise your data. gg stands for grammar of graphics. The command with which you start to build a plot is ggplot() and its argument is the data frame that contains the data to be plotted. Then you add the so called aesthetic mappings with aes() as well as functions for the type of the plot, the labels, legend, etc. Every function is connected through + (not with pipes!). 7.1 Boxplots Boxplots are some of the most useful visualisations in research and science. In R they are created with the command geom_boxplot(). First, we’ll show how the boxplot in chapter ?? was created. The function ggplot() receives the data frame vdata. In aes() we state that F1 shall be plotted on the y-axis. And finally, we use geom_boxplot() to indicate that we want this to be a boxplot. ggplot(vdata) + aes(y = F1) + geom_boxplot() Boxplots are great for comparing values across categorical groups. These groups are commonly plotted on the x-axis. Here is an example for the duration of distinct consonants in the data frame asp: ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() Boxplots can also be visualised horizontally (although this is less common). In this case we would put the categories on the y-axis and the values on the x-axis: ggplot(asp) + aes(x = d, y = Kons) + geom_boxplot() Sometimes, the boxplot is supposed to have a notch. Simply set the argument notch = TRUE in geom_boxplot() (and, if you like, notchwidth to adapt the width of the notch): ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot(notch = TRUE) ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot(notch = TRUE, notchwidth = 0.3) Further Information: Aesthetic mappings &amp; Piping Data Frames Strictly speaking, the aesthetic mappings are an argument of the function that determines the type of the plot (e.g. of geom_boxplot()). Later on, you’ll see that some plotting functions allow or need certain arguments that are not permitted by others. In most cases, we extract the aes() function from the plot-type function because it is more legible. However, you are free to include the aesthetic mappings in the plot-type function as an argument: ggplot(asp) + geom_boxplot(aes(x = Kons, y = d), notch = TRUE, notchwidth = 0.3) Within a ggplot() all functions are connected with a plus sign. The data frame, however, can the piped onto ggplot() if you want: asp %&gt;% ggplot() + aes(x = Kons, y = d) + geom_boxplot() This can be very useful if you want to apply several functions to a data frame before plotting it. For instance, here we filter the data frame asp for observations with lexical stress before then plotting the duration of only the stressed words: asp %&gt;% filter(Bet == &quot;be&quot;) %&gt;% ggplot() + aes(x = Kons, y = d) + geom_boxplot() 7.2 Scatter- &amp; Lineplots Scatter plots are created using the functions geom_point() and/or geom_line(). These two functions can also be used together. Scatter plots usually have numeric-continuous data on their x- and y-axes. Here is a plot of the volume in decibel against the duration in milliseconds: # points: ggplot(int) + aes(x = Dauer, y = dB) + geom_point() # line: ggplot(int) + aes(x = Dauer, y = dB) + geom_line() # both: ggplot(int) + aes(x = Dauer, y = dB) + geom_line() + geom_point() Sometimes it is helpful to include reference lines in a plot. Horizontal lines are created with geom_hline(), vertical ones with geom_vline(). To draw a horizontal line, you have to tell the plot where this line is supposed to meet the y-axis. This is why geom_hline() always needs the argument yintercept. For geom_vline(), xintercept is the point at which a vertical line and the x-axis meet. Let’s add two straight lines to the plot from before: ggplot(int) + aes(x = Dauer, y = dB) + geom_point() + geom_vline(xintercept = 150) + geom_hline(yintercept = 35) 7.3 Barplots Another important type of plot is the barplot which is created using geom_bar(). You can only use x or y in the aesthetic mappings because the opposite axis always shows a count or a proportion which is kindly computed by ggplot. The following plot shows, for example, how many occurrences there are of the three regions in the data frame coronal: ggplot(coronal) + aes(x = Region) + geom_bar() The bars can also be plotted horizontally by using y instead of x in the aesthetic mappings. ggplot(coronal) + aes(y = Region) + geom_bar() You can easily comprehend the plotted counts here by means of the table() function: table(coronal$Region) ## ## R1 R2 R3 ## 81 80 79 A barplot can also contain another categorical variable. The second variable to be plotted is given to the argument fill which represents the levels of that variable as fillers. In the next chapter you’ll learn how to choose these colours yourself. In the following plot, you can see how often the fricatives Fr “s” (red) and “sh” (blue) were produced in each of the three regions: ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar() Let’s try to use summarise() and group_by() to comprehend how this plot came about. We group by region and fricative and then let the function n() within summarise() determine the number of observations in the data frame for each combination of the two variables. coronal %&gt;% group_by(Region, Fr) %&gt;% summarise(count = n()) ## `summarise()` has grouped output by &#39;Region&#39;. You can ## override using the `.groups` argument. ## # A tibble: 6 × 3 ## # Groups: Region [3] ## Region Fr count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 R1 s 58 ## 2 R1 sh 23 ## 3 R2 s 59 ## 4 R2 sh 21 ## 5 R3 s 66 ## 6 R3 sh 13 A further argument of geom_bar() is position… # ...to plot proportions instead of an absolute count: ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar(position = &quot;fill&quot;) # ...to plot the bars next to each other: ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar(position = &quot;dodge&quot;) 7.4 Histograms &amp; Probability Density Histograms show the distribution of numeric-continuous data by dividing the range of values into many little sections. Similarly to the barplot, the bars (called bins here), show how many data points are within a range of values. In ggplot, histograms are created with geom_histogram(). The aesthetic mappings argument x determines which column from the data frame is plotted. Here is a histogram of F1 values in vdata: ggplot(vdata) + aes(x = F1) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. In order to be able to visually differentiate the bins, let’s give them a white border. This is achieved by means of the argument color = \"white\" in geom_histogram(): ggplot(vdata) + aes(x = F1) + geom_histogram(color = &quot;white&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. We can also determine ourselves how wide the bins are supposed to be, with the argument binwidth. Currently, one bin in our plot has a width of about 40 Hz. The following plot shows the same data as before, but with bins that have a width of 10 Hz or 100 Hz, respectively: ggplot(vdata) + aes(x = F1) + geom_histogram(color = &quot;white&quot;, binwidth = 10) ggplot(vdata) + aes(x = F1) + geom_histogram(color = &quot;white&quot;, binwidth = 100) You can see that this makes a huge difference in representing the data – so please choose carefully when you change the binwidth in a histogram. The probability density is related to the histogram. The only change we need to make to turn our histogram into a probability density is to set the argument y = ..density.. in aes(). This changes the y-axis in such a way that we see the probability density instead of the count of data points. The area of the bins of a probability density plot is by definition always 1. ggplot(vdata) + aes(x = F1, y = ..density..) + geom_histogram(color = &quot;white&quot;, binwidth = 100) ## Warning: The dot-dot notation (`..density..`) was deprecated in ## ggplot2 3.4.0. ## ℹ Please use `after_stat(density)` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see ## where this warning was generated. The probability density is computed as count / (n * binwidth) where n is the number of data points. In the histogram above with binwidth = 100 there are 285 data points (count) in the bin between 150 Hz and 250 Hz. The probability density for this bin is computed as follows: count &lt;- 285 n &lt;- nrow(vdata) binwidth &lt;- 100 dens &lt;- count / (n * binwidth) dens ## [1] 0.0009557 This value dens is the same as the density value for the same bin in our probability density plot. The area of this bin is computed as binwidth * binheight, thus: area &lt;- binwidth * dens area ## [1] 0.09557 If you sum the area of all bins in this plot, you will find that the total area is 1. Now imagine a probability density plot consisting of infinitely many bins (which would accordingly have to be infinitely narrow). Then these are not distinct bins anymore, but instead a continuous function called probability density function. There is a function for this in ggplot2, too, called geom_density(). ggplot(vdata) + aes(x = F1) + geom_density() Just like in the probability density histogram, the integral (i.e. the area) under this density curve is 1. Further Information: Histograms and Probability Density For further information, consult Wilke’s Fundamentals of Data Visualization in R, chapter 7. "],["tidying-data-with-tidyr.html", "8 Tidying Data with tidyr 8.1 Tibbles 8.2 Pivoting 8.3 Separating", " 8 Tidying Data with tidyr Please load the following packages and data frames for this chapter: library(tidyverse) library(magrittr) library(gridExtra) ## ## Attaching package: &#39;gridExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## combine url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) avokal &lt;- read.table(file.path(url, &quot;avokal.txt&quot;)) vcv &lt;- read.table(file.path(url, &quot;vcvC.txt&quot;)) “tidy datasets are all alike but every messy dataset is messy in its own way” – Hadley Wickham Hadley Wickham is the chief developer of the tidyverse. The functions of the tidyverse can not only be used to manipulate and process data, but also to clean them. A clean dataset follows these three principles: Every column contains one variable Every row contains one observation Every cell contains one value These principles may seem obvious and trivial, but they will be helpful in your everyday work with data in R. You should follow the tidy-data-principles for two main reasons: First, every dataset will be structured in the same consistent way which will facilitate every analysis. Second, the functions of the tidyverse were made to work on columns so it is very reasonable to have one variable per column. In order to demonstrate this we’ll show you examples of the two most common types of messy data. Column names are not variables, but values: The columns schnell (engl. fast) and langsam (engl. slow) in the data frame avokal are actually values of the variable velocity. avokal ## schnell langsam Vpn ## 1 430 415 S1 ## 2 266 238 S2 ## 3 567 390 S3 ## 4 531 410 S4 ## 5 707 605 S5 ## 6 716 609 S6 ## 7 651 632 S7 ## 8 589 523 S8 ## 9 469 411 S9 ## 10 723 612 S10 Several variables are stored in one column: The column Context in the data frame vcv contains two kinds of information: the left and right phonetic context of a sound. It would be better to separate these into two columns which actually already exist in the data frame (Left and Right). vcv %&gt;% head() ## RT Subject Vowel Lang Left Right Context ## 361 647.5 S209 a AE f h f.h ## 362 617.0 S209 a AE f sh f.sh ## 363 728.5 S209 a AE f sh f.sh ## 364 629.0 S209 a AE f th f.th ## 365 688.5 S209 a AE f th f.th ## 366 602.5 S209 a AE s h s.h It is not trivial to structure a data frame cleanly. Just one example: You have measured the first four formants in vowels. Does it make more sense to have the elicited data in four columns F1, F2, F3, F4? Or rather in two columns Hz (with the formant values in Hertz) and formant (with the values 1, 2, 3, or 4)? Before we show you how to restructure the datasets above such that they follow the three principles, we want to introduce the tibble. 8.1 Tibbles The *tibble is a simpler version of a data frame which is often used in the tidyverse. Let’s load another data frame and transform it into a tibble using as_tibble(): vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) %&gt;% as_tibble() When we now enter the name of that tibble, vdata, in the console, we don’t see the full dataset as usual, but instead only the first ten observations. In addition, we can see how many rows and columns the tibble consists of and which object classes the columns have: vdata ## # A tibble: 2,982 × 10 ## X Y F1 F2 dur V Tense Cons ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 53.0 4.36 313 966 107. % - P ## 2 53.6 3.65 322 2058 86.0 I - T ## 3 55.1 10.4 336 1186 123. Y - K ## 4 53.1 4.75 693 2149 119. E - T ## 5 52.7 6.46 269 2008 196. Y + K ## 6 53.3 4.7 347 931 77.5 Y - P ## 7 54.4 3.6 705 1119 224. A + P ## 8 51.2 7.38 248 2377 145. I + P ## 9 54.6 2.4 385 1935 103 Y - T ## 10 58.4 9.17 288 595 244. O + T ## # ℹ 2,972 more rows ## # ℹ 2 more variables: Rate &lt;chr&gt;, Subj &lt;chr&gt; The tibble has the primary object class tbl_df, but additionally also tbl and data.frame. That is why we can still speak of data frames when we refer to a tibble. vdata %&gt;% class() ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Of course you can also create a tibble yourself, by using the function tibble() instead of data.frame(), e.g.: tibble(x = 1:5, y = 6:10) ## # A tibble: 5 × 2 ## x y ## &lt;int&gt; &lt;int&gt; ## 1 1 6 ## 2 2 7 ## 3 3 8 ## 4 4 9 ## 5 5 10 If you use the import function read_delim() from the tidyverse package readr instead of the read.table() function, the dataset is imported as a tibble automatically. int &lt;- read_delim(file.path(url, &quot;intdauer.txt&quot;), delim = &quot; &quot;, col_names = c(&quot;idx&quot;, &quot;Vpn&quot;, &quot;dB&quot;, &quot;Dauer&quot;), skip = 1) ## Rows: 15 Columns: 4 ## ── Column specification ─────────────────────────────── ## Delimiter: &quot; &quot; ## chr (1): Vpn ## dbl (3): idx, dB, Dauer ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. int ## # A tibble: 15 × 4 ## idx Vpn dB Dauer ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 S1 24.5 162 ## 2 2 S2 32.5 120 ## 3 3 S2 38.0 223 ## 4 4 S2 28.4 131 ## 5 5 S1 23.5 67 ## 6 6 S2 37.8 169 ## 7 7 S2 30.1 81 ## 8 8 S1 24.5 192 ## 9 9 S1 21.4 116 ## 10 10 S2 25.6 55 ## 11 11 S1 40.2 252 ## 12 12 S1 44.3 232 ## 13 13 S1 26.6 144 ## 14 14 S1 20.9 103 ## 15 15 S2 26.0 212 read_delim() also returns the object class for every column in the so called Column specification. The import functions from readr are somewhat more sensitive than the standard R functions. Hier, for instance, we had to specify a few arguments (delim, col_names, and skip) in order to handle the fact that the data frame contained row indices. The standard function read.table() usually works if you just submit the path to the dataset. Further Information: Tibbles and readr If you’d like to learn more about the tibble, we recommend chapter 10 from R for Data Science. The package readr offers further functions to load and save datasets, depending on how columns are separated in the file: read_csv(): comma separated values read_csv2(): columns separated by semicolon read_tsv(): columns separated by tab read_delim(): works for all kinds of separators This and much more can also be found in chapter 11 from R for Data Science. 8.2 Pivoting Once we have loaded our data, we can start cleaning them. We can pursue two aims with this: either to structure the data in such a way that every row contains one observation and every column contains one variable, or to structure the data such that it serves a specific purpose, e.g. plotting. tidyr calls this process pivoting and there is a great vignette about the topic: vignette(&quot;pivot&quot;) Above we loaded the data frame avokal and observed that the columns schnell (fast) and langsam (slow) are actually two values of the variable velocity. That is, it would be better to have a column velocity (values: “schnell”, “langsam”) and one called duration (values from schnell and langsam in milliseconds): avokal %&gt;% pivot_longer(cols = c(schnell, langsam), names_to = &quot;velocity&quot;, values_to = &quot;duration&quot;) ## # A tibble: 20 × 3 ## Vpn velocity duration ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 S1 schnell 430 ## 2 S1 langsam 415 ## 3 S2 schnell 266 ## 4 S2 langsam 238 ## 5 S3 schnell 567 ## 6 S3 langsam 390 ## 7 S4 schnell 531 ## 8 S4 langsam 410 ## 9 S5 schnell 707 ## 10 S5 langsam 605 ## 11 S6 schnell 716 ## 12 S6 langsam 609 ## 13 S7 schnell 651 ## 14 S7 langsam 632 ## 15 S8 schnell 589 ## 16 S8 langsam 523 ## 17 S9 schnell 469 ## 18 S9 langsam 411 ## 19 S10 schnell 723 ## 20 S10 langsam 612 The command pivot_longer() transforms the data into the so called “long format”. The three most important arguments are: cols: all columns that shall be transformed values_to: the name of the new column with the values names_to: the name of the new column that will contain the original column names The pivoting functions from tidyr are very powerful and you can do really complicated operations with them. Let’s take the data frame billboard which is loaded together with the tidyverse and contains the Billboard Chart rankings from the year 2000: billboard ## # A tibble: 317 × 79 ## artist track date.entered wk1 wk2 wk3 wk4 ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Pac Baby… 2000-02-26 87 82 72 77 ## 2 2Ge+her The … 2000-09-02 91 87 92 NA ## 3 3 Doors … Kryp… 2000-04-08 81 70 68 67 ## 4 3 Doors … Loser 2000-10-21 76 76 72 69 ## 5 504 Boyz Wobb… 2000-04-15 57 34 25 17 ## 6 98^0 Give… 2000-08-19 51 39 34 26 ## 7 A*Teens Danc… 2000-07-08 97 97 96 95 ## 8 Aaliyah I Do… 2000-01-29 84 62 51 41 ## 9 Aaliyah Try … 2000-03-18 59 53 38 28 ## 10 Adams, Y… Open… 2000-08-26 76 76 74 69 ## # ℹ 307 more rows ## # ℹ 72 more variables: wk5 &lt;dbl&gt;, wk6 &lt;dbl&gt;, ## # wk7 &lt;dbl&gt;, wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, ## # wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, ## # wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, ## # wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, ## # wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, … Similarly to avokal, billboard presents another case in which some columns (wk1, wk2, wk3, etc.) are actually values of one variable (week). So we’d like to create one column which contains the week (1, 2, 3, etc.) and one column that contains the Billboard rank. To achieve this, we take all colums whose names start with “wk”, put these names in a new column called week, and the values from the original columns into a new column called rank. The prefex “wk” from the old column names can be dropped by means of the argument names_prefix. Lastly, we remove all NA (not available) values – for instance, there is no row for week 8 of 2Pac’s “Baby Don’t Cry” because the song didn’t rank in the top 100 that week. billboard %&gt;% pivot_longer(cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, names_prefix = &quot;wk&quot;, values_drop_na = TRUE) ## # A tibble: 5,307 × 5 ## artist track date.entered week rank ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 1 87 ## 2 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 2 82 ## 3 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 3 72 ## 4 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 4 77 ## 5 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 5 87 ## 6 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 6 94 ## 7 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 7 99 ## 8 2Ge+her The Hardest Part O… 2000-09-02 1 91 ## 9 2Ge+her The Hardest Part O… 2000-09-02 2 87 ## 10 2Ge+her The Hardest Part O… 2000-09-02 3 92 ## # ℹ 5,297 more rows The counterpart to pivot_longer() is pivot_wider(). This function is used much less frequently and takes as main arguments: names_from: the column containing the unique values that shall be used as new column names values_from: the column containing the values to fill the new columns A use case for pivot_wider() is given by the data frame us_rent_income which is loaded withe the tidyverse (much like billboard and a few others): us_rent_income ## # A tibble: 104 × 5 ## GEOID NAME variable estimate moe ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama income 24476 136 ## 2 01 Alabama rent 747 3 ## 3 02 Alaska income 32940 508 ## 4 02 Alaska rent 1200 13 ## 5 04 Arizona income 27517 148 ## 6 04 Arizona rent 972 4 ## 7 05 Arkansas income 23789 165 ## 8 05 Arkansas rent 709 5 ## 9 06 California income 29454 109 ## 10 06 California rent 1358 3 ## # ℹ 94 more rows We want to create a column income and a column rent from the levels of the column variable and fill the two new columns with the values from estimate. us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = estimate) ## # A tibble: 104 × 5 ## GEOID NAME moe income rent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama 136 24476 NA ## 2 01 Alabama 3 NA 747 ## 3 02 Alaska 508 32940 NA ## 4 02 Alaska 13 NA 1200 ## 5 04 Arizona 148 27517 NA ## 6 04 Arizona 4 NA 972 ## 7 05 Arkansas 165 23789 NA ## 8 05 Arkansas 5 NA 709 ## 9 06 California 109 29454 NA ## 10 06 California 3 NA 1358 ## # ℹ 94 more rows The results contains a few NA values. These can be replaced by zeros by means of the argument values_fill. us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = estimate, values_fill = 0) ## # A tibble: 104 × 5 ## GEOID NAME moe income rent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama 136 24476 0 ## 2 01 Alabama 3 0 747 ## 3 02 Alaska 508 32940 0 ## 4 02 Alaska 13 0 1200 ## 5 04 Arizona 148 27517 0 ## 6 04 Arizona 4 0 972 ## 7 05 Arkansas 165 23789 0 ## 8 05 Arkansas 5 0 709 ## 9 06 California 109 29454 0 ## 10 06 California 3 0 1358 ## # ℹ 94 more rows Again, pivot_wider() can conduct some very complex operations. The main arguments names_from and values_from can actually take more than one column. pivot_wider() then creates as many new columns as there are combinations of levels from the original columns. Here we put in the columns estimate and moe for values_from. Thus, we receive four new columns: us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe)) ## # A tibble: 52 × 6 ## GEOID NAME estimate_income estimate_rent moe_income ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alab… 24476 747 136 ## 2 02 Alas… 32940 1200 508 ## 3 04 Ariz… 27517 972 148 ## 4 05 Arka… 23789 709 165 ## 5 06 Cali… 29454 1358 109 ## 6 08 Colo… 32401 1125 109 ## 7 09 Conn… 35326 1123 195 ## 8 10 Dela… 31560 1076 247 ## 9 11 Dist… 43198 1424 681 ## 10 12 Flor… 25952 1077 70 ## # ℹ 42 more rows ## # ℹ 1 more variable: moe_rent &lt;dbl&gt; Last but not least a phonetic example. We want to create new columns from the levels of the column Bet (lexical stress) in the data frame asp and fill them with the duration values in column d. The code throws a warning because there are several values per cell in the new columns as you can also tell from the weird output: asp %&gt;% pivot_wider(names_from = Bet, values_from = d) ## Warning: Values from `d` are not uniquely identified; output ## will contain list-cols. ## • Use `values_fn = list` to suppress this warning. ## • Use `values_fn = {summary_fun}` to summarise ## duplicates. ## • Use the following dplyr code to identify duplicates. ## {data} |&gt; ## dplyr::summarise(n = dplyr::n(), .by = c(Wort, Vpn, ## Kons, Bet)) |&gt; ## dplyr::filter(n &gt; 1L) ## # A tibble: 1,723 × 5 ## Wort Vpn Kons un be ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 Fruehlingswetter k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 2 Gestern k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 3 Montag k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 4 Vater k01 t &lt;dbl [4]&gt; &lt;NULL&gt; ## 5 Tisch k01 t &lt;NULL&gt; &lt;dbl [3]&gt; ## 6 Mutter k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 7 konnte k01 k &lt;dbl [2]&gt; &lt;NULL&gt; ## 8 Kaffee k01 k &lt;NULL&gt; &lt;dbl [3]&gt; ## 9 Tassen k01 t &lt;NULL&gt; &lt;dbl [2]&gt; ## 10 Teller k01 t &lt;NULL&gt; &lt;dbl [2]&gt; ## # ℹ 1,713 more rows The warning also kindly offers three solutions to this problem: We can use the argument values_fn to suppress the warning, show how many values per cell there are, or summarise the values using one of the summarising functions. The last solution seems to make sense here: wherever there are several values per cell, we compute their mean with mean(): asp %&gt;% pivot_wider(names_from = Bet, values_from = d, values_fn = mean) ## # A tibble: 1,723 × 5 ## Wort Vpn Kons un be ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Fruehlingswetter k01 t 19.1 NA ## 2 Gestern k01 t 22.4 NA ## 3 Montag k01 t 22.3 NA ## 4 Vater k01 t 25.4 NA ## 5 Tisch k01 t NA 55.8 ## 6 Mutter k01 t 19.3 NA ## 7 konnte k01 k 43.9 NA ## 8 Kaffee k01 k NA 56.1 ## 9 Tassen k01 t NA 49.4 ## 10 Teller k01 t NA 59.4 ## # ℹ 1,713 more rows In none of the pivoting examples we overwrote the data frames with their pivoted form (e.g. with a double pipe). The functions pivot_longer() and pivot_wider() are often useful for temporary changes, e.g. because you need the data frame in a certain format for a plot: avokal %&gt;% pivot_longer(cols = c(schnell, langsam), names_to = &quot;velocity&quot;, values_to = &quot;duration&quot;) %&gt;% ggplot() + aes(x = velocity, y = duration) + geom_boxplot() 8.3 Separating Our second example for messy data was the data frame vcv which contains two types of information in the column Context: vcv %&gt;% head ## RT Subject Vowel Lang Left Right Context ## 361 647.5 S209 a AE f h f.h ## 362 617.0 S209 a AE f sh f.sh ## 363 728.5 S209 a AE f sh f.sh ## 364 629.0 S209 a AE f th f.th ## 365 688.5 S209 a AE f th f.th ## 366 602.5 S209 a AE s h s.h We want to have the left and right phonetic context, which are separated here by a dot, in separate columns. (For the purpose of this demonstration we remove the columns Left and Right from the data frame because the are the desired solution.) vcv %&lt;&gt;% select(RT:Lang, Context) %&gt;% as_tibble() To achieve our aim we use the function separate() with the following obligatory arguments: col: the column whose contents are to be separated into: the new column names sep: how to separate the strings in column col The first two arguments are pretty clear in our case: col is the column Context and into takes our desired column names Left and Right. For the third argument sep, on the other hand, there are two options. The first is to indicate the index at which to separate the string, e.g. put the first two letters in one and the rest of the letters in the second new column. To do this, we can use sep = 2. However, when we look at the distinct values in Context, this wouldn’t be our desired result: levels(vcv$Context) ## NULL This is because the left context can consist of one or two letters; and also, there is a dot which would then be inherited by the left or right context, as you can see here: vcv %&gt;% separate(col = Context, into = c(&quot;Left&quot;, &quot;Right&quot;), sep = 1) ## # A tibble: 810 × 6 ## RT Subject Vowel Lang Left Right ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f .h ## 2 617 S209 a AE f .sh ## 3 728. S209 a AE f .sh ## 4 629 S209 a AE f .th ## 5 688. S209 a AE f .th ## 6 602. S209 a AE s .h ## 7 632. S209 a AE s .sh ## 8 574 S209 a AE s .th ## 9 719 S209 a AE s .h ## 10 569 S209 a AE s .th ## # ℹ 800 more rows vcv %&gt;% separate(col = Context, into = c(&quot;Left&quot;, &quot;Right&quot;), sep = 2) ## # A tibble: 810 × 6 ## RT Subject Vowel Lang Left Right ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f. h ## 2 617 S209 a AE f. sh ## 3 728. S209 a AE f. sh ## 4 629 S209 a AE f. th ## 5 688. S209 a AE f. th ## 6 602. S209 a AE s. h ## 7 632. S209 a AE s. sh ## 8 574 S209 a AE s. th ## 9 719 S209 a AE s. h ## 10 569 S209 a AE s. th ## # ℹ 800 more rows The second option is a regular expression (also called regex). That means that we give the function a pattern that tells it how to separate the contents of Context. This would work well here because we would like to separate the contexts at the dot. Unfortunately, the dot is a marker for one (random) character in regular expressions. So if we want to indicate in our pattern that we actually mean a dot (and not any random character), we need to protect the dot by means of the escape sign, a double backslash. vcv %&gt;% separate(col = Context, into = c(&quot;Left&quot;, &quot;Right&quot;), sep = &quot;\\\\.&quot;) ## # A tibble: 810 × 6 ## RT Subject Vowel Lang Left Right ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f h ## 2 617 S209 a AE f sh ## 3 728. S209 a AE f sh ## 4 629 S209 a AE f th ## 5 688. S209 a AE f th ## 6 602. S209 a AE s h ## 7 632. S209 a AE s sh ## 8 574 S209 a AE s th ## 9 719 S209 a AE s h ## 10 569 S209 a AE s th ## # ℹ 800 more rows So this is the result we aimed for: every column contains only one variable! Further Information: regular expressions Regexs are a complex topic which we cannot get into in this module. If you want to learn more about them – they are very useful in any programming language after all – we recommend chapter 14 from R for Data Science. "],["joining-with-dplyr.html", "9 Joining with dplyr 9.1 Mutating Joins 9.2 Filtering Joins", " 9 Joining with dplyr Please load the following packages and data frame for this chapter: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; vcv &lt;- read.table(file.path(url, &quot;vcvC.txt&quot;)) Perhaps you are familiar with so called joins from your work with relational data bases and/or SQL. The principle of relational data bases is to store all information and values in themed tables. After an experiment, for instance, you might have a table of measured values (formants, fundamental frequency, etc.) and one table with metadata about the participants (age, origin, education, etc.). Additionally it might make sense to have a table with information about the collected material (words, lexical stress, phonemes, stimuli, etc.) and about the tested conditions (speech rate, which interlocutor, etc.). If necessary, one can (temporarily) join two tables via a key, i.e. a column that contains some sort of ID. In dplyr we differentiate between mutating joins and filtering joins. 9.1 Mutating Joins Similarly to mutate(), mutating joins add columns to a data frame x. Contrary to mutate() though, the added columns come from a different data frame y. In both data frames x and y there must be a column that contains the identifier or key which connects the two tables. 9.1.1 Inner Join The simplest form of a mutating join is the so called inner join. The function inner_join() takes as arguments the two data frames x and y and the identifier by. The result of an inner join contains all columns of both x and y as well as all rows that have matches in both data frames. Missing values (NA) do not appear in the result of an inner join, so be careful with that. As an example we will be using a table of fundamental frequency values measured in the speech of ten speakers, as well as a table with metadata concerning the speakers: measures &lt;- tibble(subject = rep(paste0(&quot;s&quot;, 1:10), each = 10), F0 = rnorm(100, 120, 15)) measures ## # A tibble: 100 × 2 ## subject F0 ## &lt;chr&gt; &lt;dbl&gt; ## 1 s1 103. ## 2 s1 115. ## 3 s1 129. ## 4 s1 146. ## 5 s1 95.2 ## 6 s1 114. ## 7 s1 114. ## 8 s1 147. ## 9 s1 104. ## 10 s1 88.6 ## # ℹ 90 more rows meta &lt;- tibble(subject = paste0(&quot;s&quot;, 1:10), age = rep(c(&quot;old&quot;, &quot;young&quot;), each = 5)) meta ## # A tibble: 10 × 2 ## subject age ## &lt;chr&gt; &lt;chr&gt; ## 1 s1 old ## 2 s2 old ## 3 s3 old ## 4 s4 old ## 5 s5 old ## 6 s6 young ## 7 s7 young ## 8 s8 young ## 9 s9 young ## 10 s10 young Both tibbles have a column subject which we will use as key in our inner join: inner_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 100 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 103. old ## 2 s1 115. old ## 3 s1 129. old ## 4 s1 146. old ## 5 s1 95.2 old ## 6 s1 114. old ## 7 s1 114. old ## 8 s1 147. old ## 9 s1 104. old ## 10 s1 88.6 old ## # ℹ 90 more rows It can happen that the column that provides the identifier has different names in x and y. In this case we can tell the join via by = c(\"a\"=\"b\") that the column a from data frame x shall be matched with the column b from data frame y. This works for all joining functions presented in this chapter. measures %&lt;&gt;% rename(Vpn = subject) inner_join(x = measures, y = meta, by = c(&quot;Vpn&quot;=&quot;subject&quot;)) ## # A tibble: 100 × 3 ## Vpn F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 103. old ## 2 s1 115. old ## 3 s1 129. old ## 4 s1 146. old ## 5 s1 95.2 old ## 6 s1 114. old ## 7 s1 114. old ## 8 s1 147. old ## 9 s1 104. old ## 10 s1 88.6 old ## # ℹ 90 more rows measures %&lt;&gt;% rename(subject = Vpn) This example has so far always returned all observations from measures and all columns of both data frames. This is because measures and meta both contain information on the same ten speakers. If we have less information in one of the two data frames, the result is suddenly missing rows: # measures of 20 instead of 10 speakers: measures &lt;- tibble(subject = rep(paste0(&quot;s&quot;, 1:20), each = 10), F0 = rnorm(200, 120, 15)) inner_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 100 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 154. old ## 2 s1 133. old ## 3 s1 108. old ## 4 s1 127. old ## 5 s1 128. old ## 6 s1 107. old ## 7 s1 93.8 old ## 8 s1 115. old ## 9 s1 103. old ## 10 s1 128. old ## # ℹ 90 more rows The result of this inner join has no rows for speakers 11 to 20 because there is no information on these speakers in the data frame meta! 9.1.2 Outer Join Contrary to the inner join, the outer join keeps rows with missing values. The missing values are shown as NA. The simplest version of an outer join is the full join which returns all rows and all columns from both data frames. The function to do this is full_join() (we point out an interesting part of the result here using slice()): full_join(x = measures, y = meta, by = &quot;subject&quot;) %&gt;% slice(95:105) ## # A tibble: 11 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s10 131. young ## 2 s10 101. young ## 3 s10 144. young ## 4 s10 111. young ## 5 s10 135. young ## 6 s10 123. young ## 7 s11 133. &lt;NA&gt; ## 8 s11 109. &lt;NA&gt; ## 9 s11 96.3 &lt;NA&gt; ## 10 s11 118. &lt;NA&gt; ## 11 s11 110. &lt;NA&gt; This result consists of 200 rows (if we do not use slice()) – when we used the inner join above with the exact same two tibbles, the result only consisted of 100 rows. This is because full_join() kept the 100 rows of values for speakers 11 to 20 while inner_join() removed them because there was no matching metadata for these speakers in meta. Thus, the result of the full join contains NA values in the appended column age for speakers 11 to 20. If you don’t want to keep all rows from both data frames, the functions left_join() and right_join() are at your disposal. The left_join() keeps all rows from data frame x while the right_join() keeps all rows from data frame y. In our example we want to keep all rows from measures and just add the information on the speakers’ age from meta: left_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 200 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 154. old ## 2 s1 133. old ## 3 s1 108. old ## 4 s1 127. old ## 5 s1 128. old ## 6 s1 107. old ## 7 s1 93.8 old ## 8 s1 115. old ## 9 s1 103. old ## 10 s1 128. old ## # ℹ 190 more rows right_join(x = meta, y = measures, by = &quot;subject&quot;) ## # A tibble: 200 × 3 ## subject age F0 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 s1 old 154. ## 2 s1 old 133. ## 3 s1 old 108. ## 4 s1 old 127. ## 5 s1 old 128. ## 6 s1 old 107. ## 7 s1 old 93.8 ## 8 s1 old 115. ## 9 s1 old 103. ## 10 s1 old 128. ## # ℹ 190 more rows 9.2 Filtering Joins The second type of joins in R are the so called filtering joins which do not add columns but instead only return selected rows. There are two functions for this in the tidyverse: semi_join(): returns all observations in data frame x for which there is a match in data frame y anti_join(): returns all observations in data frame x for which there is no match in data frame y We will demonstrate these functions using the following data frames: vcv %&lt;&gt;% as_tibble() vcv ## # A tibble: 810 × 7 ## RT Subject Vowel Lang Left Right Context ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f h f.h ## 2 617 S209 a AE f sh f.sh ## 3 728. S209 a AE f sh f.sh ## 4 629 S209 a AE f th f.th ## 5 688. S209 a AE f th f.th ## 6 602. S209 a AE s h s.h ## 7 632. S209 a AE s sh s.sh ## 8 574 S209 a AE s th s.th ## 9 719 S209 a AE s h s.h ## 10 569 S209 a AE s th s.th ## # ℹ 800 more rows vcv_summary &lt;- vcv %&gt;% group_by(Subject, Vowel) %&gt;% summarise(mean_rt = mean(RT)) %&gt;% ungroup() %&gt;% slice_max(mean_rt, n = 5) ## `summarise()` has grouped output by &#39;Subject&#39;. You can ## override using the `.groups` argument. vcv_summary ## # A tibble: 5 × 3 ## Subject Vowel mean_rt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 S502 i 1173. ## 2 S502 u 1076. ## 3 S502 a 1000. ## 4 S508 u 816. ## 5 S508 i 780. The data frame vcv_summary contains the five highest mean reaction times and the corresponding speaker and vowel. If we want to find out from which observations in vcv these mean values were calculated, we can use the semi join. More precisely, we want all rows from vcv returned for which there is a match in vcv_summary with respect to the columns Subject and Vowel. semi_join(x = vcv, y = vcv_summary, by = c(&quot;Subject&quot;, &quot;Vowel&quot;)) ## # A tibble: 75 × 7 ## RT Subject Vowel Lang Left Right Context ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1120. S502 a D f h f.h ## 2 1066. S502 a D f sh f.sh ## 3 848 S502 a D f sh f.sh ## 4 1148. S502 a D f th f.th ## 5 1130 S502 a D f th f.th ## 6 938 S502 a D s h s.h ## 7 1124. S502 a D s sh s.sh ## 8 981 S502 a D s th s.th ## 9 774 S502 a D s h s.h ## 10 1104 S502 a D s th s.th ## # ℹ 65 more rows This result contains all observations from which the average reaction times in vcv_summary were computed. We can underline this by looking at the unique combinations of Subject and Vowel in the result of the semi join – they are the same five combinations as in vcv_summary. semi_join(x = vcv, y = vcv_summary, by = c(&quot;Subject&quot;, &quot;Vowel&quot;)) %&gt;% select(Subject, Vowel) %&gt;% unique() ## # A tibble: 5 × 2 ## Subject Vowel ## &lt;chr&gt; &lt;chr&gt; ## 1 S502 a ## 2 S502 i ## 3 S502 u ## 4 S508 i ## 5 S508 u With the anti join, on the other hand, we get all observations from which the mean reaction times were not computed, or in other words: all observations from vcv for which there is no match in vcv_summary with regard to Subject and Vowel. anti_join(x = vcv, y = vcv_summary, by = c(&quot;Subject&quot;, &quot;Vowel&quot;)) ## # A tibble: 735 × 7 ## RT Subject Vowel Lang Left Right Context ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f h f.h ## 2 617 S209 a AE f sh f.sh ## 3 728. S209 a AE f sh f.sh ## 4 629 S209 a AE f th f.th ## 5 688. S209 a AE f th f.th ## 6 602. S209 a AE s h s.h ## 7 632. S209 a AE s sh s.sh ## 8 574 S209 a AE s th s.th ## 9 719 S209 a AE s h s.h ## 10 569 S209 a AE s th s.th ## # ℹ 725 more rows Anti joins can be helpful in searching for errors in your own data. Let’s reuse the example from above, measures with values for 20 speakers and meta with metadata for these speakers. If we apply the anti join here, we will immediately see for which rows in measures there is no match in meta, i.e. for which speakers we are missing metadata. anti_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 100 × 2 ## subject F0 ## &lt;chr&gt; &lt;dbl&gt; ## 1 s11 133. ## 2 s11 109. ## 3 s11 96.3 ## 4 s11 118. ## 5 s11 110. ## 6 s11 127. ## 7 s11 120. ## 8 s11 97.4 ## 9 s11 119. ## 10 s11 101. ## # ℹ 90 more rows The result is the opposite of the inner join: Here we receive the 100 observations from speakers 11 to 20 for whom there is no metadata. Further Information: dplyr The joins were the last functions from the tidyverse which we introduce in this module. An overview of all functions presented here and many more can be found in this Cheatsheet. "],["pretty-plots.html", "10 Pretty Plots 10.1 Axis Labels 10.2 Limit the Coordinate System 10.3 Colours 10.4 Further Specifications 10.5 Font Size 10.6 Dividing and Arranging Plots", " 10 Pretty Plots Load the following packages and data frames for this chapter: library(tidyverse) library(magrittr) library(gridExtra) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) %&gt;% as_tibble() coronal &lt;- read.table(file.path(url, &quot;coronal.txt&quot;)) %&gt;% as_tibble() vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) %&gt;% as_tibble() int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) %&gt;% as_tibble() ggplot2 offers very many ways of improving and personalising your plots. In this chapter we introduce the most important plot specifications. 10.1 Axis Labels Axis labels are created with xlab() and ylab(), respectively. A title can be added with ggtitle(). ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() + xlab(&quot;Place of Articulation&quot;) + ylab(&quot;Duration (ms)&quot;) + ggtitle(&quot;Boxplot Data&quot;) Otherwise you can also use labs() for all labels together: ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar(position = &quot;fill&quot;) + labs(x = &quot;Region&quot;, y = &quot;Proportion&quot;, title = &quot;Proportional Use of Fricatives&quot;, subtitle = &quot;Separated by Region&quot;) 10.2 Limit the Coordinate System In order to limit or expand the visible area of a plot, you can use the following functions. However, they have various side effects (also see here): xlim() and/or ylim(), respectively scale_x_continuous(limits = c()) and/or scale_y_continuous(limits = c()): eliminates data points by zooming in and throws a warning about that. These functions may affect regression lines and other superimposed plot components. coord_cartesian(xlim = c(), ylim = c()): hides data points and thus does not throw a warning. This does not influence regression lines and other superimposed plot components. # without limits: ggplot(int) + aes(x = dB, y = Dauer) + geom_point() # with coord_cartesian() ggplot(int) + aes(x = dB, y = Dauer) + geom_point() + coord_cartesian(xlim = c(10,40), ylim = c(30,280)) # with xlim() and ylim() ggplot(int) + aes(x = dB, y = Dauer) + geom_point() + xlim(10, 40) + ylim(30, 280) ## Warning: Removed 2 rows containing missing values or values ## outside the scale range (`geom_point()`). 10.3 Colours ggplot2 always uses the same colour palette by default. But there are many more colours at your disposal as shown in this selection. You can get the first ten of these with: colors() # only show the first ten: colors()[1:10] ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; ## [4] &quot;antiquewhite1&quot; &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; ## [7] &quot;antiquewhite4&quot; &quot;aquamarine&quot; &quot;aquamarine1&quot; ## [10] &quot;aquamarine2&quot; The variable to be colour-coded in a ggplot is given by col (outline or line colour) or fill (filler colour) in the aesthetic mapping. This is what it looks like to colour-code the variable Kons in a boxplot of durations: # with &quot;fill&quot; (recommended!) ggplot(asp) + aes(x = Kons, y = d, fill = Kons) + geom_boxplot() # with &quot;col&quot; (dispreferred!) ggplot(asp) + aes(x = Kons, y = d, col = Kons) + geom_boxplot() As you can see, a legend for the colours was automatically added to the plot. Now, let’s choose the colours ourselves: # &quot;fill&quot; with our own colours colours &lt;- c(&quot;darkgoldenrod1&quot;, &quot;navy&quot;) ggplot(asp) + aes(y = d, x = Kons, fill = Kons) + geom_boxplot(fill = colours) This plot does not have a legend. If we want to have one, we need to use the functions scale_color_manual() or scale_fill_manual(), respectively: # &quot;fill&quot; with our own colours colours &lt;- c(&quot;darkgoldenrod1&quot;, &quot;navy&quot;) ggplot(asp) + aes(y = d, x = Kons, fill = Kons) + geom_boxplot() + scale_fill_manual(values = colours) # the same for the bar plot ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar() + scale_fill_manual(values = colours) By the way, boxplots offer the possibility of styling the outliers independently of the box: colours &lt;- c(&quot;darkgoldenrod1&quot;, &quot;navy&quot;) ggplot(asp) + aes(y = d, x = Kons, fill = Bet) + geom_boxplot(outlier.color = &quot;red&quot;, outlier.shape = 4, outlier.size = 3) + scale_fill_manual(values = colours) 10.4 Further Specifications Of course there are many more specifications for the distinct types of plots than just the colour, e.g. the size, line type, shape of points, font… col: outline or line colour fill: filler colour shape: shape of points size: size of points linewidth: width of lines lty: line type stroke: font stroke There is a vignette about that: vignette(&quot;ggplot2-specs&quot;) Let’s use some of these specifications here: ggplot(int) + aes(x = dB, y = Dauer) + geom_point(col = &quot;purple&quot;, size = 3, shape = 0) + geom_line(col = &quot;orange&quot;, size = 1.5, lty = &quot;twodash&quot;) ## Warning: Using `size` aesthetic for lines was deprecated in ## ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see ## where this warning was generated. Always consider carefully whether a specification is actually necessary in order to make the plot clearer. 10.5 Font Size The default font size of the axes and title is 11pt or smaller. Especially in presentations your plots should have font sizes of at least 16-24pt. In order to do that in ggplot, we need to change the theme(). ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() + xlab(&quot;Place of Articulation&quot;) + ylab(&quot;Duration (ms)&quot;) + ggtitle(&quot;Boxplot Data&quot;) + theme(text = element_text(size = 24), # Axes and title axis.text = element_text(size = 18)) # Axis labels Further Information: theme() The theme() is responsible for the background colour of the plots, the appearance of the axes and many other things. An overview of the arguments to theme() might give you an impression of all the things you can adapt in your plots. 10.6 Dividing and Arranging Plots 10.6.1 Dividing Plots ggplot2 offers two ways of dividing a plot: facet_wrap() and facet_grid(). The main argument to these functions is the usually categorical variable(s) whose values shall appear in distinct panels. For instance, we can plot data points associated with different phonemes or speakers in separate panels. The formulas submitted to facet_wrap() and facet_grid() look like this: .~Var1 or ~Var1 Var1~. (the dot is obligatory!) Var1~Var2 Var1+Var2~Var3 Var1~Var2+Var3 It is impractical to use more than three variables in facet_wrap() and facet_grid() because that makes the plot way harder to read and comprehend. facet_wrap() sorts the panels of a plot into rows and columns. # divide by subject ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_wrap(~Subj) # divide by subject and tenseness ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_wrap(Subj~Tense) facet_grid(), on the other hand, sorts the panels into either rows or columns. The order for the formula is facet_grid(rows~columns). # divide by subject in rows ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_grid(Subj~.) # divide by subject in columns ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_grid(~Subj) # divide by subject and tenseness ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_grid(Subj~Tense) 10.6.2 Arrange Plots Furthermore, you can arrange several plots beside each other or one below the other. For that, we use the function grid.arrange() from the library gridExtra. plot1 &lt;- ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() plot2 &lt;- ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar() plot3 &lt;- ggplot(int) + aes(x = dB, y = Dauer) + geom_line() + geom_point() # in three columns and one row grid.arrange(plot1, plot2, plot3, ncol = 3, nrow = 1) # in one column and three rows grid.arrange(plot1, plot2, plot3, ncol = 1, nrow = 3) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
