[["index.html", "Programmieren in R: eine Einführung für PhonetikerInnen 1 Setup 1.1 Installation und Kursverzeichnis 1.2 R projects 1.3 Packages und R Version 1.4 Sessions 1.5 Dokumentarten 1.6 Hilfe zur Selbsthilfe", " Programmieren in R: eine Einführung für PhonetikerInnen Johanna Cronenberg 2024-03-14 1 Setup 1.1 Installation und Kursverzeichnis Laden Sie die Statistik-Software R herunter und installieren Sie sie. Die neueste Version ist derzeit 4.3.x (Stand: März 2024). Laden Sie außerdem RStudio herunter und installieren Sie es. Schauen Sie sich diese kurze Einführung in RStudio an. Legen Sie außerdem ein Verzeichnis für diesen Kurs auf Ihrer Festplatte an. 1.2 R projects Für diesen Kurs werden wir ein R project anlegen, da Ihnen dies die Arbeit mit R auf lange Sicht erleichtern wird. Öffnen Sie RStudio und klicken Sie oben rechts auf die Schaltfläche Project: (None). Klicken Sie dann auf New Project und im Folgenden auf Existing Directory und wählen Sie mit Browse das Kursverzeichnis aus, das Sie eben angelegt haben. Schließen Sie den Vorgang ab, indem Sie auf Create Project klicken. RStudio öffnet nun automatisch das Projekt, das genauso benannt ist wie Ihr Kursverzeichnis (siehe Schaltfläche oben rechts). Sie können das Projekt über diese Schaltfläche schließen und anschließend auch wieder öffnen. Das Projekt lässt sich außerdem öffnen, indem Sie in Ihrem Kursverzeichnis auf die neu angelegte Datei mit der Endung .Rproj klicken. Sollten Sie Probleme beim Erstellen des Projekts haben, empfehlen wir Ihnen diese Video-Kurzanleitung. Weiterführende Infos: R Projekte R Projekte haben viele Vorteile, insbesondere wenn Sie in mehreren Kursen mit R arbeiten und für jeden ein eigenes R Projekt haben. Das Projekt merkt sich, welche Dateien Sie geöffnet haben, und stellt diese beim nächsten Öffnen des Projekts wieder her, sodass Sie da weiterarbeiten können, wo Sie aufgehört haben. Außerdem ist das working directory des Projekts Ihr Kursverzeichnis, das heißt alle Dateien, die Sie im Verlauf des Kurses dort ablegen, können Sie ganz einfach über das Panel unten links (Tab Files) oder über relative Pfade öffnen. Ihr Arbeitsverzeichnis können Sie übrigens überprüfen, indem Sie in der Konsole getwd() eingeben und Enter drücken. 1.3 Packages und R Version Für R gibt es viele Tausend packages bzw. libraries, die uns die Arbeit erleichtern werden. Bitte installieren Sie nun folgende Packages (das dauert eine Weile!): install.packages(c(&quot;Rcpp&quot;, &quot;remotes&quot;, &quot;knitr&quot;, &quot;tidyverse&quot;, &quot;magrittr&quot;, &quot;rmarkdown&quot;, &quot;emuR&quot;, &quot;gridExtra&quot;, &quot;emmeans&quot;, &quot;broom&quot;, &quot;lmerTest&quot;, &quot;pbkrtest&quot;, &quot;MuMIn&quot;)) Weiterführende Infos: Installation von R Paketen Sollte der obige Befehl den Fehler installation of package had non-zero exit status werfen, hat die Installation eines oder mehrerer Pakete nicht geklappt. Für Windows kann es sein, dass Sie in diesem Fall zusätzlich Rtools installieren müssen. Für MacOS müssen Sie ggf. die XCode command-line tools installieren und/oder resetten. Öffnen Sie dafür ein Mac Terminal und führen Sie folgende Befehle aus: xcode-select --install # Falls die Installation der R Packages dann immer noch nicht klappt: xcode-select --reset Wenn Sie sich unsicher sind, wie Sie auftretende Fehler bei der Installation der R Packages für Ihr Betriebssystem beheben können, können Sie mich auch gerne fragen! Einige Basispakete werden automatisch aktiviert beim Öffnen von RStudio, die meisten aber müssen Sie erst laden, bevor Sie die Funktionen verwenden können, die die Pakete anbieten. Zum Laden von Packages benutzen Sie den Befehl library(): library(tidyverse) library(emuR) Weiterführende Infos: Updates Bitte überprüfen Sie regelmäßig, ob Ihre Packages Updates benötigen – die Updates werden in R nicht automatisch eingespielt! Klicken Sie hierfür in der Werkzeugleiste auf Tools &gt; Check for Package Updates. Auch RStudio selbst erhält ab und zu Updates, dies können Sie überprüfen mit Help &gt; Check for Updates. R muss ebenfalls aktuell gehalten werden. Sie können Ihre R Version überprüfen mit getRversion(). Besuchen Sie einfach in regelmäßigen Abständen die R Webseite und schauen Sie, ob eine neue stabile Version verfügbar ist. 1.4 Sessions Eine Session beginnt, wenn man R bzw. RStudio startet bzw. wenn man ein Projekt öffnet. Man beendet eine Session entweder mit Session &gt; Quit Session in der Werkzeugleiste oder mit Strg+Q bzw. Ctrl+Q oder mit der Konsoleneingabe q(). Die Session endet außerdem automatisch, wenn Sie RStudio schließen. Sie werden dann gefragt, ob Sie das workspace image speichern wollen. Wenn Sie die Variablen, die Sie in der Session angelegt haben, im Environment behalten und in der nächsten Session wieder verwenden wollen, klicken Sie auf Save. Der workspace wird dann in Ihrem Kursverzeichnis in einer Datei mit der Endung .RData abgelegt. Wenn Sie den workspace nicht speichern möchten, klicken Sie auf Don't save. Falls Sie die Session doch nicht beenden wollen, klicken Sie auf Cancel. Für diesen Kurs bitte ich Sie, den workspace nicht zu speichern (Don't save). 1.5 Dokumentarten 1.5.1 R Skripte Die Konsole in RStudio ist die direkte Verbindung zu R, d.h. dort kann R Code direkt ausgeführt werden. Um aber Ihren Code jederzeit replizieren zu können, müssen Sie ihn in einem Dokument festhalten. Üblicherweise werden Sie das in Ihrem Arbeitsalltag in einem R Skript machen. Ein R Skript kann einfach erstellt werden über File &gt; New File &gt; R Script (bzw. Strg + Shift + N) und sollte immer mit der Dateiendung .R abgespeichert werden. Ein R Skript enthält ausschließlich ausführbaren Code. Beim Ausführen eines Skriptes wird eine Zeile nur dann von R ignoriert, wenn sie mit # beginnt; dann ist die Zeile auskommentiert. Es gibt verschiedene Möglichkeiten, ein R Skript auszuführen. Markieren Sie die gewünschten Zeilen (wenn es nur eine Zeile ist, setzen Sie einfach den Cursor in die Zeile), und klicken Sie in der kleinen Werkzeugleiste im Panel mit dem geöffneten Skript auf Run oder drücken Sie Strg+Enter bzw. Ctrl+Enter. Das Ergebnis sehen Sie sofort in der Konsole. 1.5.2 R Markdown In den letzten Jahren hat sich aber auch eine andere Dokumentart etabliert, insbesondere für die Erstellung von Berichten und Lehrmaterial: das R Markdown. R Markdown ist eine Art Textdokument, in das man Code Snippets einbetten kann, die ganz normal ausgeführt werden können (wie oben beschrieben). Ein solches Dokument enthält häufig mehr Text als Code. Sie können ein R Markdown erstellen mit File &gt; New File &gt; R Markdown und es ist Konvention, das Dokument mit der Dateiendung .Rmd abzuspeichern. Eine R Markdown Datei wird im Normalfall in ein anderes Format umgewandelt (“ge-knitted”), z.B. in eine HTML, eine PDF, oder sogar ein Word Dokument. Dies geschieht entweder über den Wollknäuel-Button mit der Aufschrift Knit oder mittels: library(rmarkdown) render(&quot;document.Rmd&quot;) Wir benutzen R Markdown auch, um z.B. die HTML herzustellen, die Sie gerade lesen. Im Markdown Dokument werden für Textmarkierungen besondere Zeichen verwendet, die dann beim knitten interpretiert und umgesetzt werden: # Überschrift: Mit einem Hashtag bekommt man die größtmögliche Überschrift; je mehr Hashtags man benutzt, desto kleiner wird die Überschrift. **fett**: Mit doppeltem Asterisk vor und hinter einer Textpassage wird der Text fett gesetzt. *kursiv*: Mit einfachem Asterisk wird der Text kursiv. `code`: Die einfachen rückwärts gewandten Anführungszeichen heben den darin enthaltenen Text hervor; das wird üblicherweise für Code oder Variablen benutzt, wenn man sich außerhalb eines Code Snippets befindet; dieser Code kann aber nicht ausgeführt werden! ```: Die dreifachen rückwarts gewandten Anführungszeichen markieren den Anfang und das Ende eine Code Snippets (auch Code Block genannt). Dazwischen darf nur Code geschrieben werden; Text muss mit einem Hashtag als Kommentar verfasst werden. Am Anfang des Code Snippets wird außerdem in geschweiften Klammern angegeben, welche Programmiersprache man im Code Block schreibt (in unserem Fall: {r}). Noch mehr Informationen dazu finden Sie im Cheatsheet zu R Markdown (insb. Seite 2, linke Spalte). 1.6 Hilfe zur Selbsthilfe 1.6.1 Fehler erkennen Warnzeichen: Wenn Sie einen Syntaxfehler in einem Dokument haben (beispielsweise eine vergessene Klammer), sehen Sie am Rand kleine rote Warnzeichen. Diese sollten nicht ignoriert werden, denn sie weisen darauf hin, dass Sie einen Fehler gemacht haben. Wenn Sie den Fehler korrigieren, verschwinden die Warnzeichen. “Knit”: Wir empfehlen, dass Sie Ihr Markdown-Dokument regelmäßig in eine HTML überführen, indem Sie oben in der Werkzeugleiste auf “Knit” klicken. Wenn alles klappt, sehen Sie hoffentlich in einem neuen Fenster oder im Viewer (Panel unten rechts in RStudio) die kompilierte HTML. Wenn Sie aber Syntaxfehler oder andere Fehler in Ihrem Code haben, wird die HTML nicht erstellt und Sie kriegen stattdessen einen Fehler in der Konsole angezeigt. Dort sehen Sie auch, in welcher Zeile der Fehler ist. Code einzeln ausführen: Führen Sie jede neu geschriebene Zeile Code aus. So sehen Sie Ihr Ergebnis und können überlegen, ob das Ergebnis das gewünschte ist oder nicht. 1.6.2 Community nutzen Es gibt eine sehr große und hilfsbereite R Community, die Ihnen das Programmieren lernen mit R erleichtern wird. Hier ein paar gute Links und Befehle, falls Sie mal nicht weiter wissen: Stack Overflow: Ein Blog, auf dem Sie höchstwahrscheinlich eine Antwort auf Ihre Frage zu R finden werden. Am einfachsten googlen Sie Ihre Frage auf Englisch; die Antwort eines Mitglieds von Stack Overflow wird bei den ersten Suchergebnissen dabei sein. Hadley Wickham’s “R for Data Science”: Hadley Wickham ist der Chief Programmer des “tidyverse”, mit dem wir uns noch auseinandersetzen werden. Seine Bücher sind sehr verständlich, gut strukturiert und kurzweilig zu lesen. Cheatsheets: Das sind PDFs, die eine Funktionsübersicht mit Erklärungen und ggf. Beispielen in absoluter Kurzform bieten. Sie finden einige Cheatsheets in der obersten Werkzeugleiste unter Help &gt; Cheatsheets. Insbesondere die ersten drei sind für Sie interessant. Ansonsten kann man Cheatsheets auch googlen und findet dann z.B. Data Transformation with dplyr oder diese sehr ausführliche Reference Card. Vignetten: Zu einigen essentiellen Paketen gibt es so genannte “Vignetten”, das sind meist HTMLs oder PDFs, die die AutorInnen eines Pakets geschrieben haben. Sie können mit folgender Konsoleneingabe nach Vignetten suchen: # zum Beispiel zu einer Library aus dem tidyverse: vignette(&quot;dplyr&quot;) In RStudio können Sie sich über die Eigenschaften einer Funktion informieren, indem Sie im Panel unten rechts mit dem Tab Help die gewünschte Funktion ins Suchfeld eingeben. Sie erhalten dann u.a. Informationen über die Argumente der Funktion und Beispiele. Dasselbe erreichen Sie über diese Konsoleneingaben (beispielhaft für Hilfe zur Funktion getwd()): ?getwd help(&quot;getwd&quot;) 1.6.3 Hilfe zu ggplot2 ggplot2 ist nicht nur bekannt, sondern auch beliebt! Dementsprechend viel Hilfe bekommen Sie von der R Community. Hier ein paar gute Quellen für Hilfe bei der Erstellung von Abbildungen: Kapitel Data Visualisation in Hadley Wickham’s “R for Data Science” Cookbook for R Cheatsheet ggplot2 Stack Overflow 1.6.4 Statistik in R: Literatur Wenn Sie mehr Informationen zu benötigen, seien Ihnen folgende Werke ans Herz gelegt: Bodo Winter’s “Statistics for Linguists: An Introduction using R”: Ein frisch erschienenes Buch voller hervorragender Erklärungen zu allen wichtigen Themen der Inferenzstatistik. Ist über die Uni-Bib digital verfügbar. Stefan Gries’ “Statistics for Linguistics with R: A Practical Introduction”: Nützlich für die Entscheidungsfindung, welches statistische Modell zu den eigenen Daten und der eigenen Fragestellung passt. Da das Buch von 2009 ist, ist der Code z.T. veraltet, aber aus statistischer Sicht ist der Inhalt noch aktuell. Ist über die Uni-Bib digital verfügbar. Harald Baayen’s “Analyzing Linguistic Data: A Practical Introduction to Statistics”: Einführung für eher Fortgeschrittene. Hier ist der R Code ebenfalls oft veraltet, aber die Erklärungen und Beispiele zu den Statistikgrundlagen sind hilfreich. Als physisches Exemplar in der Unibib verfügbar. "],["erste-berechnungen-in-r.html", "2 Erste Berechnungen in R 2.1 Variablen &amp; Funktionen 2.2 Objektklassen 2.3 Vektoren 2.4 Arithmetik und logische Operatoren 2.5 Vektoren manipulieren 2.6 Faktoren", " 2 Erste Berechnungen in R Unten links in RStudio sehen Sie die Console. Darin wird Code ausgeführt, d.h. die Konsole ist die Verbindung zwischen R und dem Computer, der die Berechnungen umsetzt. Geben Sie z.B. den folgenden Code Zeile für Zeile in die Konsole ein und drücken Sie nach jeder Zeile Enter: 1 + 1 ## [1] 2 10 - 5 ## [1] 5 3 * 4 ## [1] 12 12 / 6 ## [1] 2 2^4 ## [1] 16 Die Konsole gibt Ihnen die Antwort auf die eingegebene Rechnung zurück. 2.1 Variablen &amp; Funktionen Natürlich werden wir die Konsole nicht nur als Taschenrechner benutzen. Ganz häufig wollen wir bestimmte Werte mehrfach verwenden, ohne jedes Mal den Wert oder die Berechnung eingeben zu müssen. Deshalb speichern wir Werte als sogenannte Variablen ab. Diese Variablen sind dann in Ihrem Environment (Panel oben rechts) vorhanden. Um eine neue Variable anzulegen, gibt man in der Konsole zuerst den gewünschten Variablennamen ein, dann den Zuweisungspfeil &lt;- und dann den zu speichernden Wert. Im folgenden legen wir eine Variable namens summe an, die den Wert 1 + 1 enthält: summe &lt;- 1 + 1 Um den Inhalt der Variable anzusehen, geben Sie einfach den Variablennamen in die Konsole ein und drücken wieder Enter: summe ## [1] 2 Sie sehen, dass nicht 1 + 1 zurückgegeben wird, sondern 2. Wann immer wir den Wert der Berechnung 1 + 1 verwenden wollen, können wir stattdessen auch summe verwenden: summe + 3 ## [1] 5 Achtung! Variablen werden in R ohne Warnmeldung überschrieben: x &lt;- 4 x ## [1] 4 x &lt;- 3 x ## [1] 3 In Ihrem Environment haben Sie nun zwei Variablen: summe hat den Wert 2, x hat den Wert 3. Sie können auch herausbekommen, welche Variablen in Ihrem Environment sind, indem Sie eine sogenannte Funktion verwenden. Funktionen (auch: Befehle) führen Aktionen aus. Dahinter steht Code, den jemand geschrieben und für alle NutzerInnen verfügbar gemacht hat (man kann auch selbst Funktionen schreiben, aber das werden wir in diesem Kurs nicht behandeln). Geben Sie folgendes in Ihre Konsole ein und drücken Sie Enter: ls() ## [1] &quot;githubs&quot; &quot;summe&quot; &quot;x&quot; Die Funktion heißt ls(), das steht für list (auflisten), und gibt Ihnen die Namen aller Variablen in Ihrem Environment zurück. Funktionen können Sie an den runden Klammern nach dem Funktionsnamen erkennen. In den runden Klammern stehen die sogenannten Argumente der Funktion, also Angaben, die die Funktion benötigt, um etwas berechnen zu können. ls() ist eine der wenigen Funktionen in R, die keine Argumente benötigen. Eine weitere nützliche Funktion ist rm() (remove), damit können Sie Variablen aus dem Environment entfernen (Achtung: diese Entscheidung ist endgültig!). Die Funktion bekommt als Argumente die Namen der Variablen, die Sie löschen wollen. Im Folgenden entfernen wir die Variable x: rm(x) ls() ## [1] &quot;githubs&quot; &quot;summe&quot; 2.2 Objektklassen Bisher haben wir nur mit Zahlen (sog. numerics) gearbeitet. In R gibt es noch viele weitere Arten von Objekten. Bei den numerischen Objekten unterscheidet man zwischen double (Dezimalzahlen) und integer (Ganzzahlen). x &lt;- 3.2 # double x ## [1] 3.2 y &lt;- 4 # integer y ## [1] 4 Es gibt außerdem Schriftzeichen-Objekte (engl. strings oder character), die immer in Anführungszeichen gesetzt werden müssen: z &lt;- &quot;Hallo Welt!&quot; z ## [1] &quot;Hallo Welt!&quot; … und die zwei booleschen Werte (engl. booleans oder logicals), die ohne Anführungszeichen aber in Großbuchstaben geschrieben werden: a &lt;- TRUE # Kurzform: T a ## [1] TRUE b &lt;- FALSE # Kurzform: F b ## [1] FALSE Es gibt zusätzlich noch eine wichtige Objektklasse namens factor, die für kategorische Daten verwendet wird. Diese Art von Daten werden wir, zusammen mit noch ein paar weiteren Objektklassen, später kennenlernen. Um herauszufinden, welche Objektklasse eine Variable hat, verwendet man die Funktion class(). Diese Funktion bekommt nur ein Argument, nämlich den Namen der Variable, deren Objektklasse Sie erfragen wollen. class(a) ## [1] &quot;logical&quot; class(y) ## [1] &quot;numeric&quot; class(z) ## [1] &quot;character&quot; 2.3 Vektoren Die Funktion c() (concatenate) erzeugt einen Vektor, d.h. eine Datenstruktur mit mehreren Elementen desselben Typs. vec &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # alle Elemente sind Schriftzeichen vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; vec &lt;- c(3, 6, 89.3, 0, -10) # alle Elemente sind numerisch (genauer: doubles) vec ## [1] 3.0 6.0 89.3 0.0 -10.0 Sollten die Elemente unterschiedlichen Klassen angehören (strings, booleans, numerics), werden die Elemente still, also ohne Warnmeldung, in denselben Typ umgewandelt. c(3, 4, &quot;string&quot;, T) # alle Elemente werden in strings umgewandelt ## [1] &quot;3&quot; &quot;4&quot; &quot;string&quot; &quot;TRUE&quot; c(2, 5, T, F) # alle Elemente werden in numerics umgewandelt; TRUE = 1, FALSE = 0 ## [1] 2 5 1 0 2.4 Arithmetik und logische Operatoren Sie haben schon gesehen, dass die Konsole wie ein Taschenrechner funktioniert. Die Grundrechenarten sowie arithmetische Funktionen können Sie auf alle numerischen Objekte anwenden, auch auf numerische Vektoren: a &lt;- c(10, 4, 20) a * 10 ## [1] 100 40 200 b &lt;- c(5, 2, 7) a + b ## [1] 15 6 27 In R gibt es viele arithmetische Funktionen, die als Argument einfach eine numerische Variable bekommen: sum(a) # Summe aller Elemente ## [1] 34 sqrt(a) # Wurzel (square root) pro Element ## [1] 3.162 2.000 4.472 log(a) # Logarithmus eines jeden Elements ## [1] 2.303 1.386 2.996 exp(a) # Exponential für jedes Element ## [1] 2.203e+04 5.460e+01 4.852e+08 Logische Operatoren vergleichen zwei Variablen derselben Objektklasse miteinander. Die folgenden logischen Operatoren existieren in R: x &lt; y # weniger als x &gt; y # mehr als x &lt;= y # weniger als oder gleich x &gt;= y # mehr als oder gleich x == y # genau gleich x != y # ungleich !x # nicht x x | y # x ODER y x &amp; y # x UND y isTRUE(x) # prüfen, ob x TRUE ist x %in% y # prüfen, ob ein Wert x in einem Vektor y enthalten ist Die Antwort auf diese Operatoren sind die booleschen Werte, also entweder TRUE oder FALSE, wie folgende Beispiele zeigen: x &lt;- 3 y &lt;- 4 x == y ## [1] FALSE x != y ## [1] TRUE x &gt; y ## [1] FALSE x &lt;- c(1, 2, 3, 4, 5) x == 3 ## [1] FALSE FALSE TRUE FALSE FALSE &quot;a&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## [1] TRUE Die logischen Operatoren werden später noch sehr wichtig werden. 2.5 Vektoren manipulieren Wir wollen Ihnen noch ein paar Funktionen vorstellen, die hilfreich bei der Arbeit mit Vektoren sind. Neben c() gibt es noch weitere Funktionen, mit denen man Vektoren erstellen kann. Zuerst gibt es eine Kurznotation für numerische Vektoren von aufeinander folgenden Ganzzahlen, nämlich den Doppelpunkt: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 Die Funktion seq() erzeugt einen Vektor mit numerischen Intervallen, also Zahlensequenzen, bei denen alle Zahlen gleich weit voneinander entfernt sind. Die Funktion bekommt drei Argumente: den ersten (from) und den maximalen (nicht zwangsläufig letzten) Wert des Intervalls (to), und dann entweder die gewünschte Länge des Vektors (length.out) oder die Abstufung des Intervalls (by). seq(from = 10, to = 20, length.out = 5) # 5 Intervalle zwischen 10 und 20 ## [1] 10.0 12.5 15.0 17.5 20.0 seq(from = 10, to = 20, by = 1.5) # in Intervallen von 1.5 ## [1] 10.0 11.5 13.0 14.5 16.0 17.5 19.0 Weiterführende Infos: Argumente in Funktionen Oben sehen Sie zum ersten Mal, dass Funktionsargumente Namen haben können (z.B. from, to, length.out und by). Wenn Argumente Namen haben (was fast immer der Fall ist), können Sie entweder die Namen dieser Argumente verwenden wie oben gezeigt, oder Sie lassen die Namen komplett weg. seq(10, 20, length.out = 5) ## [1] 10.0 12.5 15.0 17.5 20.0 Wenn Sie die Namen weglassen, müssen Sie die Argumente in der richtigen Reihenfolge verwenden. Die Reihenfolge der Argumente können Sie auf den Hilfeseiten herausfinden. Navigieren Sie dazu in den Tab Help im Panel unten rechts und geben Sie den Funktionsnamen seq in die Suchleiste ein. Wenn Sie Enter drücken, sollte die Hilfeseite der Funktion erscheinen. Die Reihenfolge der Argumente für diese Funktion ist from, to und dann entweder by oder length.out, wie Sie sehen können. Wir können die Argumentnamen from und to weglassen, solange wir die richtigen Zahlen an der richtigen Stelle in der Funktion verwenden (also zuerst den Wert für from, dann den Wert für to). Der Funktion ist aber nicht automatisch klar, ob als drittes Argument by oder length.out kommt, daher schreiben wir das Argument hier ausführlich als length.out = 5. Wenn wir dies nicht machen würden, würde die Funktion das Argument an dritter Stelle in der Funktion als den Wert für by interpretieren: seq(10, 20, 5) ## [1] 10 15 20 Wenn wir allerdings die Namen der Argumente verwenden, ist die Reihenfolge egal: seq(to = 20, by = 1.5, from = 10) ## [1] 10.0 11.5 13.0 14.5 16.0 17.5 19.0 Die Funktion rep() wiederholt Werte (egal ob numerisch, logisch oder strings). Neben den zu wiederholenden Werten bekommt die Funktion das Argument times und/oder das Argument each (oder das Argument length.out, das wir hier erstmal ignorieren). Im folgenden demonstrieren wir, was diese Argumente anrichten (schauen Sie auch auf die Hilfsseite für diese Funktion!): rep(1, times = 3) ## [1] 1 1 1 rep(&quot;a&quot;, times = 2) ## [1] &quot;a&quot; &quot;a&quot; vek &lt;- c(&quot;a&quot;, &quot;b&quot;) rep(vek, times = 4) ## [1] &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; rep(vek, each = 4) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; rep(vek, times = 3, each = 3) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; ## [13] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; Zuletzt gibt es noch zwei verwandte Funktionen, die Schriftzeichen-Vektoren generieren: paste() und paste0(). Die Funktion paste() bekommt zunächst all die Elemente, die Sie miteinander verbinden wollen, und optional das Argument sep (separator), das bestimmt, mit welchem Zeichen die Elemente verbunden werden. paste0() bekommt nur die Elemente, die dann direkt aneinander gebunden werden. Wenn die Elemente alle einfache Variablen sind, erstellen paste() und paste0() ein einfaches Schriftzeichenobjekt, wenn eines der Elemente ein Vektor ist, ergibt sich ein Schriftzeichen-Vektor. paste(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot; &quot;) ## [1] &quot;a b c&quot; paste(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;&quot;) ## [1] &quot;abc&quot; paste0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## [1] &quot;abc&quot; paste(&quot;subject&quot;, 1:5, sep = &quot;_&quot;) ## [1] &quot;subject_1&quot; &quot;subject_2&quot; &quot;subject_3&quot; &quot;subject_4&quot; ## [5] &quot;subject_5&quot; paste0(&quot;subject&quot;, 1:5) ## [1] &quot;subject1&quot; &quot;subject2&quot; &quot;subject3&quot; &quot;subject4&quot; ## [5] &quot;subject5&quot; Es gibt noch einige weitere nützliche Funktionen, um Vektoren zu manipulieren oder etwas über den Inhalt der Vektoren zu erfahren. Schauen Sie mal in Ihr Environment. Dort befinden sich jetzt drei einfache Variablen: summe, y und z. Alle anderen Variablen sind Vektoren. Sie sehen z.B. bei der Variable a, dass es sich um einen numerischen Vektor der Länge 3 (d.h. er enthält 3 Elemente) handelt: dort steht num [1:3]. num steht für numeric, die Notation [1:3] bedeutet, dass dies ein eindimensionales Objekt der Länge 3 ist. Um die Länge eines Vektors herauszufinden, ohne in Ihr Environment zu schauen, gibt es die Funktion length(): length(a) ## [1] 3 length(vec) ## [1] 5 Wenn Sie erfahren möchten, welche unterschiedlichen (einzigartigen) Elemente in einem Vektor sind, nutzen Sie unique(): vec &lt;- c(1, 5, 2, 7, 6, 3, 7, 5) unique(vec) ## [1] 1 5 2 7 6 3 vec &lt;- c(&quot;i&quot;, &quot;i&quot;, &quot;a&quot;, &quot;a&quot;, &quot;E&quot;, &quot;E&quot;, &quot;E&quot;, &quot;E&quot;, &quot;U&quot;) unique(vec) ## [1] &quot;i&quot; &quot;a&quot; &quot;E&quot; &quot;U&quot; Zuletzt stellen wir Ihnen noch eine sehr vielseitig einsetzbare Funktion vor, nämlich table(). Wenn diese Funktion auf einen Vektor angewendet wird, erhalten Sie als Ergebnis eine Auflistung der unterschiedlichen Elemente des Vektors mit ihrer Vorkommenshäufigkeit in diesem Vektor: table(vec) ## vec ## a E i U ## 2 4 2 1 Im Vektor vec gibt es also zwei Mal das Element “a”, vier Mal das Element “E”, usw. Wir werden später noch sehen, wofür table() sonst noch eingesetzt werden kann. 2.6 Faktoren Nachdem Sie jetzt wissen, was ein Vektor ist, möchten wir Ihnen noch eine Objektklasse namens Faktor (factor) vorstellen. Faktoren werden für kategoriale Daten verwendet, also solche, die nur eine begrenzte Anzahl an verschiedenartigen Werten annehmen können. Einen Faktor erzeugt man mit der Funktion factor(). Hier erzeugen wir zum Beispiel einen Faktoren-Vektor, der verschiedene Alterskategorien enthält: age &lt;- factor(c(&quot;jung&quot;, &quot;alt&quot;, &quot;alt&quot;, &quot;mittel&quot;, &quot;jung&quot;, &quot;jung&quot;)) class(age) ## [1] &quot;factor&quot; age ## [1] jung alt alt mittel jung jung ## Levels: alt jung mittel Bei der Ausgabe des Faktors age, den wir angelegt haben, sehen wir zuerst die eingegebenen Werte in der eingegebenen Reihenfolge. Obwohl wir die Werte als Schriftzeichen eingegeben haben, werden sie nicht als Schriftzeichen (in Anführungszeichen) ausgegeben. Das liegt daran, dass dies jetzt nicht mehr einfache Schriftzeichen, sondern Kategorien sind. Die Kategorien werden auch Levels genannt und in der Ausgabe ebenfalls angezeigt. Man kann die Levels auch mittels der Funktion levels() abfragen: levels(age) ## [1] &quot;alt&quot; &quot;jung&quot; &quot;mittel&quot; Die Funktion factor() kann ein Argument namens levels bekommen, mit dem man die Levels selbst bestimmen und ihre Reihenfolge festlegen kann (R ordnet die Levels sonst alpha-numerisch aufsteigend). age &lt;- factor(c(&quot;jung&quot;, &quot;alt&quot;, &quot;alt&quot;, &quot;mittel&quot;, &quot;jung&quot;, &quot;jung&quot;), levels = c(&quot;jung&quot;, &quot;mittel&quot;, &quot;alt&quot;)) age ## [1] jung alt alt mittel jung jung ## Levels: jung mittel alt Auch numerische Werte können (in eher seltenen Fällen) kategorial sein. Nehmen wir an, Sie haben fünf Kommilitoninnen nach ihrem Alter in Jahren gefragt und die Werte in einem Vektor abgespeichert: age &lt;- c(22, 25, 23, 22, 23) Wenn Sie das Alter in Jahren als kategorial betrachten, können Sie den Vektor in einen Faktor umwandeln. age &lt;- factor(c(22, 25, 23, 22, 23)) age ## [1] 22 25 23 22 23 ## Levels: 22 23 25 "],["data-frames.html", "3 Data Frames 3.1 Import &amp; Export 3.2 Eigenschaften 3.3 Auf Spalten zugreifen", " 3 Data Frames Eine äußerst wichtige Datenstruktur in R ist der Data Frame. Das ist eine zwei-dimensionale Tabelle. Die Zeilen werden auch observations genannt und die Spalten variables (nicht zu verwechseln mit den Variablen, d.h. abgespeicherten Werten und Objekten, wie im vorherigen Kapitel besprochen!). In der Phonetik arbeiten wir sehr häufig mit Data Frames, z.B. wenn wir akustische Informationen aus Sprachaufnahmen oder Messungen aus einem Perzeptionsexperiment extrahiert haben und diese auswerten oder statistisch analysieren wollen. 3.1 Import &amp; Export In R gibt es verschiedene Möglichkeiten, eine Tabelle im Format .csv oder .txt einzulesen. Wenn Sie eine Tabelle von Ihrer Festplatte einlesen wollen, können Sie im Panel mit dem Environment in der Werkzeugleiste auf Import Dataset klicken und sich von dem Assistenten leiten lassen. Der Befehl, den der Assistent zum Laden des Data Frames verwendet, wird übrigens in der Konsole angezeigt. In diesem Kurs werden wir u.a. Data Frames von einer Webseite benutzen, daher müssen wir den Befehl zum Einlesen selbst schreiben. Der Befehl, den wir verwenden, lautet read.table(), und bekommt als wichtigstes Argument in Anführungszeichen den Pfad (bzw. die URL) zu dem Data Frame (aber schauen Sie auf die Hilfeseite dieser Funktion, um alle Argumente und weitere verwandte Funktionen zum Einlesen von Daten zu sehen): ai &lt;- read.table(&quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf/ai.txt&quot;) Da wir im Verlauf der Vorlesung mehrere Data Frames von derselben Webseite verwenden werden, können wir das Einlesen etwas cleverer gestalten, damit wir nicht immer wieder die komplizierte URL abtippen oder kopieren müssen. Dafür legen wir eine Variable mit der URL als Schriftzeichenobjekt an und verwenden dann die Funktion file.path(), mittels derer die URL und der Dateiname zusammengefügt werden: url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; file.path(url, &quot;ai.txt&quot;) ## [1] &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf/ai.txt&quot; # zusammen mit dem Befehl zum Einlesen: ai &lt;- read.table(file.path(url, &quot;ai.txt&quot;)) Das Gegenstück zu read.table() ist write.table(), womit Sie einen Data Frame abspeichern können. Diese Funktion bekommt zuerst den Namen des Objekts, das abgespeichert werden soll, dann den Pfad samt gewünschtem Dateinamen (./ steht für das aktuelle Verzeichnis), und als weiteres optionales Argument nutzen wir row.names = FALSE, damit es nicht eine Spalte mit den (hier nicht vorhandenen) Zeilennamen in dem abgespeicherten Data Frame gibt. write.table(ai, file.path(&quot;./&quot;, &quot;ai.txt&quot;), row.names = FALSE) Natürlich können Sie Data Frames nicht nur einlesen, sondern auch selbst erstellen. Dafür wird der Befehl data.frame() verwendet. Diese Funktion bekommt als Argumente die Spaltennamen und anschließend die Werte, die in der Spalte stehen sollen. Hier ein Beispiel: df &lt;- data.frame(F1 = c(240, 220, 250, 210, 280, 520, 510, 605, 670, 613), vowel = rep(c(&quot;i&quot;,&quot;o&quot;), each = 5)) df ## F1 vowel ## 1 240 i ## 2 220 i ## 3 250 i ## 4 210 i ## 5 280 i ## 6 520 o ## 7 510 o ## 8 605 o ## 9 670 o ## 10 613 o Data Frames haben eine eigene Objektklasse: class(df) ## [1] &quot;data.frame&quot; 3.2 Eigenschaften Wenn wir mit Datenstrukturen arbeiten, die viele Informationen enthalten, ist es wichtig, uns mit dem Objekt vertraut zu machen. R bietet viele nützliche Funktionen, um sich Data Frames anzuschauen und etwas über deren Eigenschaften zu erfahren: # Data Frame in einem Sub-Fenster anschauen View(ai) # Nur die ersten oder letzten paar Zeilen (Beobachtungen) ausgeben head(ai) ## F1 Kiefer Lippe ## 1 773 -25.48 -24.60 ## 2 287 -27.03 -26.44 ## 3 1006 -27.25 -27.59 ## 4 814 -26.06 -27.17 ## 5 814 -26.15 -25.93 ## 6 806 -26.37 -24.45 tail(ai) ## F1 Kiefer Lippe ## 20 888 -25.99 -26.85 ## 21 988 -26.27 -28.27 ## 22 650 -26.50 -24.31 ## 23 1026 -27.10 -24.64 ## 24 992 -28.41 -28.31 ## 25 896 -26.57 -25.69 # Reihen- und Spaltenanzahl nrow(ai) ## [1] 25 ncol(ai) ## [1] 3 dim(ai) ## [1] 25 3 # Spaltennamen (Variablennamen) colnames(ai) ## [1] &quot;F1&quot; &quot;Kiefer&quot; &quot;Lippe&quot; names(ai) ## [1] &quot;F1&quot; &quot;Kiefer&quot; &quot;Lippe&quot; 3.3 Auf Spalten zugreifen Obwohl wir in den kommenden Kapiteln mit der modernen tidyverse-Syntax arbeiten werden, wollen wir hier zeigen, wie man in traditioneller Weise auf Spalten in einem Data Frame zugreifen kann. Manchmal werden Sie nicht darum herum kommen, diese traditionelle Notation zu verwenden. Wenn Sie in Ihr Environment schauen, sehen Sie, dass dort unter “Values” die ganzen einfachen Variablen und Vektoren stehen und unter “Data” finden Sie die zwei Data Frames ai und df. Als Informationen zu den Data Frames stehen im Environment immer die Anzahl an observations (Zeilen) und variables (Spalten), z.B. 25 obs. of 3 variables. Wenn Sie auf das kleine blaue Icon links neben dem Namen des Data Frames klicken, sehen Sie die Spaltennamen, welcher Objektklasse die Spalten angehören (int für integer, num für numerics bzw. doubles, usw.) und die ersten paar Werte aus der Spalte. Dieselben Informationen erhalten Sie, wenn Sie die Funktion str() (structure) auf einen Data Frame anwenden: str(ai) ## &#39;data.frame&#39;: 25 obs. of 3 variables: ## $ F1 : int 773 287 1006 814 814 806 938 1005 964 931 ... ## $ Kiefer: num -25.5 -27 -27.2 -26.1 -26.2 ... ## $ Lippe : num -24.6 -26.4 -27.6 -27.2 -25.9 ... str(df) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ F1 : num 240 220 250 210 280 520 510 605 670 613 ## $ vowel: chr &quot;i&quot; &quot;i&quot; &quot;i&quot; &quot;i&quot; ... Vor jeder Spalte in dieser Auflistung steht ein Dollarzeichen. Genau so können Sie auf Spalten in einem Data Frame zugreifen: Sie schreiben den Namen des Data Frames, dann (ohne Lehrzeichen!) das Dollarzeichen, und anschließend (wieder ohne Leerzeichen!) den Spaltennamen: df$F1 ## [1] 240 220 250 210 280 520 510 605 670 613 Sie sehen, dass eine Spalte an und für sich nichts anderes ist als ein Vektor! Das heißt, Sie können die Funktionen, mit denen wir zuvor Vektoren manipuliert haben, jetzt auch auf Spalten in Data Frames anwenden: length(df$F1) ## [1] 10 table(df$vowel) ## ## i o ## 5 5 Weiterführende Infos: Factors in Data Frames Für den Data Frame df, den wir oben selbst angelegt haben, sehen Sie im Environment, dass die Spalte vowel der Objektklasse factor angehört, und dass dieser factor zwei levels hat – obwohl wir die Spalte vowel mit Schriftzeichen gefüllt hatten! Die Funktion data.frame(), mit der wir df erstellt haben, hat ein Argument namens stringsAsFactors, das, wenn nicht anders angegeben, automatisch TRUE ist. Das heißt, beim Erstellen des Data Frames wurden die Schriftzeichen in der Spalte vowel in einen factor umgewandelt. Die zwei verschiedenartigen Werte (Kategorien) in dieser Spalte sind “i” und “o”, dementsprechend hat dieser factor zwei levels. Wenn Sie sich nochmal die Informationen zu dem Data Frame df im Environment oder Ihrer Konsole anschauen, werden Sie feststellen, dass die Spalte vowel nicht nur ein Faktor mit zwei Levels ist, sondern dass die ersten Werte in dieser Spalte komischerweise Zahlen sind und nicht “i” und “o”. Das liegt daran, dass Faktoren im Hintergrund (also für die NutzerInnen meist unsichtbar) als integer abgespeichert werden. Diese integer sind mit den einzigartigen Levels des Faktors assoziiert. Wenn also in unserem Environment bei der Spalte vowel der Wert 1 steht, dann repräsentiert dies das Level “i”, der Wert 2 repräsentiert das Level “o”. Wenn Sie beim Erstellen des Data Frames verhindern möchten, dass strings in factors umgewandelt werden, verwenden Sie das Argument stringsAsFactors = FALSE: df &lt;- data.frame(F1 = c(240, 220, 250, 210, 280, 520, 510, 605, 670, 613), vowel = rep(c(&quot;i&quot;,&quot;o&quot;), each = 5), stringsAsFactors = FALSE) "],["einführung-ins-tidyverse.html", "4 Einführung ins tidyverse 4.1 Pipes 4.2 Daten manipulieren mit dplyr 4.3 Weitere Beispiele für komplexe Pipes", " 4 Einführung ins tidyverse Für dieses Kapitel benötigen Sie die folgenden Packages und Data Frames: library(tidyverse) ## ── Attaching core tidyverse packages ────────────────── ## ✔ dplyr 1.1.4 ✔ readr 2.1.5 ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ ggplot2 3.5.0 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.1 ## ✔ purrr 1.0.2 ## ── Conflicts ───────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) Nutzen Sie die Methoden aus Kapitel 3.2, um sich mit den einzelnen Data Frames vertraut zu machen! Das tidyverse ist eine Sammlung von Packages, die bei unterschiedlichen Aspekten der Datenverarbeitung helfen. Wir werden uns im Verlauf der nächsten Kapitel mit einigen dieser tidyverse-Packages beschäftigen. Wenn Sie das tidyverse laden, sehen Sie folgendes: Zum tidyverse in der Version 2.0 gehören die neun dort aufgelisteten Packages (dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, tidyr). All diese Pakete können Sie auch einzeln laden, wenn Sie das möchten. Zusätzlich wird angezeigt, dass es zwei Konflikte gibt: Die Notation dplyr::filter() bedeutet “die Funktion filter() aus dem Paket dplyr”. Diese Funktion überschreibt die Funktion filter() aus dem Paket stats (das ist ein Paket, das den NutzerInnen ohne vorheriges Laden mittels library() immer zur Verfügung steht). Funktionen aus verschiedenen Paketen können sich gegenseitig überschreiben, wenn sie denselben Funktionsnamen haben, wie z.B. filter(). Wenn man nun also filter() verwendet, wird die Funktion von dplyr verwendet, nicht die Funktion von stats. Wenn man explizit die Funktion von stats verwenden will, kann man die obige Notation verwenden, also stats::filter(). Viele Funktionen aus dem tidyverse dienen dazu, traditionelle R Notationen abzulösen. Diese traditionellen Notationen sind häufig recht sperrig; tidyverse-Code hingegen ist leicht zu lesen und zu schreiben. Wir verwenden tidyverse, um Data Frames aufzuräumen, zu filtern oder zu verändern. 4.1 Pipes Dazu müssen wir zuerst lernen, wie die tidyverse-Syntax funktioniert: asp %&gt;% head() ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un ## 3 26.81 Montag k01 t un ## 4 14.75 Vater k01 t un ## 5 42.38 Tisch k01 t be ## 6 21.56 Mutter k01 t un Wir beginnen den Code immer mit dem Date Frame und hängen dann einfach alle Funktionen, die wir auf den Data Frame anwenden wollen, in chronologischer Reihenfolge an den Data Frame. Zwischen jeder Funktion steht die Pipe %&gt;%. Die Pipe nimmt immer das, was links von der Pipe steht, und reicht es weiter an die Funktion, die rechts von der Pipe steht. Im Code oben wird also die Funktion head() auf den Data Frame asp angewendet. Dies ist genau dasselbe wie: head(asp) ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un ## 3 26.81 Montag k01 t un ## 4 14.75 Vater k01 t un ## 5 42.38 Tisch k01 t be ## 6 21.56 Mutter k01 t un In der tidyverse-Schreibweise mit der einfachen Pipe wird der Data Frame nicht verändert; das Ergebnis des Codes wird einfach in der Konsole ausgegeben. Wenn Sie das Ergebnis einer tidyverse-Pipe in einer Variable abspeichern wollen, nutzen Sie die übliche Notation mit dem Zuweisungspfeil &lt;-: numberOfRows &lt;- asp %&gt;% nrow() numberOfRows ## [1] 2892 Das Besondere ist, dass Sie so viele Funktionen mit der Pipe aneinanderhängen können wie Sie wollen. Die Funktionen werden immer auf das Ergebnis der vorherigen Funktion angewendet, wie wir gleich sehen werden. Innerhalb der Funktionen können wir dank der Pipe auf alle Spalten des Data Frames einfach mittels ihres Namens zugreifen. 4.2 Daten manipulieren mit dplyr Die wichtigsten Funktionen, die Sie in Ihrem Alltag mit R brauchen werden, stammen aus dem Package dplyr. Wir unterteilen hier nach verschiedenen Arten von Operationen, die Sie auf Data Frames ausführen können. 4.2.1 Filtering Häufig werden wir aus Data Frames bestimmte Zeilen und/oder Spalten auswählen. Das Auswählen von Zeilen erfolgt mit der Funktion filter(). Als Argument(e) bekommt die Funktion einen oder mehrere logische Ausdrücke. Hierfür benötigen Sie die logischen Operatoren aus Kapitel 2.4. Wenn Sie aus dem Data Frame asp alle Zeilen auswählen wollen, bei denen in der Spalte Wort “Montag” steht, nutzen Sie beispielsweise den Operator ==: asp %&gt;% filter(Wort == &quot;Montag&quot;) ## d Wort Vpn Kons Bet ## 3 26.81 Montag k01 t un ## 63 17.75 Montag k01 t un ## 123 45.12 Montag k02 t un ## 182 40.50 Montag k03 t un ## 241 33.00 Montag k04 t un ## 300 32.69 Montag k04 t un ## 359 50.82 Montag k05 t un ## 476 27.93 Montag k06 t un ## 537 17.25 Montag k61 t un ## 597 21.13 Montag k62 t un ## 656 20.75 Montag k62 t un ## 2078 105.94 Montag k70 t un ## 2079 17.56 Montag k70 t un ## 2080 22.25 Montag k70 t un ## 2155 60.25 Montag K19 t un ## 2156 14.87 Montag K20 t un ## 2157 17.56 Montag K20 t un ## 2231 47.31 Montag K74 t un ## 2232 34.94 Montag K74 t un ## 2233 35.44 Montag K74 t un ## 2310 22.62 Montag k61 t un ## 2311 16.43 Montag k61 t un ## 2312 29.31 Montag k61 t un ## 2391 50.31 Montag k61 t un ## 2392 33.12 Montag k61 t un ## 2393 39.68 Montag k61 t un ## 2403 42.88 Montag k61 t un ## 2424 35.44 Montag k62 t un ## 2506 11.25 Montag k62 t un ## 2528 8.06 Montag k62 t un ## 2604 33.94 Montag dlm t un ## 2624 29.87 Montag dlm t un ## 2704 30.32 Montag dlm t un ## 2725 21.93 Montag dlm t un ## 2800 49.12 Montag hpt t un ## 2821 24.87 Montag hpt t un Alle Zeilen, bei denen die Dauer d kleiner ist als 10 ms, erhält man mit folgendem Ausdruck: asp %&gt;% filter(d &lt; 10) ## d Wort Vpn Kons Bet ## 180 9.130 Fruehlingswetter k03 t un ## 205 8.440 verstauchter k03 t un ## 540 6.688 Mutter k61 t un ## 773 8.000 Butter k64 t un ## 895 7.060 Buttergeschichte k66 t un ## 982 9.500 Butter k66 t un ## 999 8.300 Butter K22 t un ## 1142 9.750 Vater K30 t un ## 1155 8.630 Schwester K61 t un ## 1170 5.690 maechtig K62 t un ## 1294 9.690 Butter k07 t un ## 1362 8.870 Freitag k08 t un ## 1548 6.500 Vater k10 t un ## 1564 8.750 spaeter k11 t un ## 1565 5.250 Sonntags k11 t un ## 2507 6.570 unterbrechen k62 t un ## 2528 8.060 Montag k62 t un ## 2542 9.500 Samstag k62 t un ## 2580 8.880 samstags k62 t un Sie können natürlich auch mehrere logische Ausdrücke miteinander verbinden, nämlich mittels den Operatoren für “und” &amp; oder für “oder” |. Mit dem folgenden Ausdruck werden nur Zeilen zurückgegeben, bei denen die Versuchsperson Vpn entweder “k01” oder “k02” oder “k03” ist und der Konsonant Kons ungleich “t”: asp %&gt;% filter(Vpn %in% c(&quot;k01&quot;, &quot;k02&quot;, &quot;k03&quot;) &amp; Kons != &quot;t&quot;) ## d Wort Vpn Kons Bet ## 7 50.00 konnte k01 k un ## 8 78.12 Kaffee k01 k be ## 11 64.13 Broetchenkorb k01 k be ## 12 48.94 keinen k01 k be ## 13 59.00 Kuchen k01 k be ## 16 56.00 einkaufen k01 k be ## 19 34.37 Zucker k01 k un ## 20 55.75 Suessigkeiten k01 k un ## 21 55.62 kaufen k01 k be ## 22 55.94 Konserven k01 k un ## 23 61.81 Kasse k01 k be ## 28 47.25 Kartoffeln k01 k un ## 31 37.62 Kaffee k01 k be ## 33 54.19 Koennen k01 k un ## 35 35.49 Dickicht k01 k un ## 40 59.44 Kuechenofen k01 k be ## 42 64.50 kocht k01 k be ## 48 69.19 Karten k01 k be ## 49 58.69 Fahrkarten k01 k be ## 53 30.82 Acker k01 k un ## 57 95.13 kurz k01 k be ## 58 57.38 verkuendet k01 k be ## 59 72.00 kommen k01 k be ## 67 37.75 konnte k01 k un ## 68 52.69 Kaffee k01 k be ## 71 71.43 Broetchenkorb k01 k be ## 72 51.75 keinen k02 k be ## 73 70.82 Kuchen k02 k be ## 76 68.19 einkaufen k02 k be ## 79 17.38 Zucker k02 k un ## 80 50.25 Suessigkeiten k02 k un ## 81 43.07 kaufen k02 k be ## 82 35.62 Konserven k02 k un ## 83 59.25 Kasse k02 k be ## 88 44.94 Kartoffeln k02 k un ## 91 34.44 Kaffee k02 k be ## 93 35.62 Koennen k02 k un ## 95 30.69 Dickicht k02 k un ## 100 72.32 Kuechenofen k02 k be ## 102 33.75 kocht k02 k be ## 108 61.06 Karten k02 k be ## 109 50.82 Fahrkarten k02 k be ## 113 23.93 Acker k02 k un ## 117 67.87 kurz k02 k be ## 118 35.62 verkuendet k02 k be ## 119 44.56 kommen k02 k be ## 127 39.87 konnte k02 k un ## 128 46.00 Kaffee k02 k be ## 131 67.57 Broetchenkorb k02 k be ## 132 58.25 keinen k02 k be ## 133 58.81 Kuchen k02 k be ## 136 54.94 einkaufen k02 k be ## 139 30.88 Zucker k02 k un ## 140 49.18 Suessigkeiten k02 k un ## 141 63.44 kaufen k02 k be ## 142 45.25 Konserven k02 k un ## 143 50.50 Kasse k02 k be ## 148 54.31 Kartoffeln k03 k un ## 151 53.25 Kaffee k03 k be ## 153 34.00 Koennen k03 k un ## 155 47.82 Dickicht k03 k un ## 160 50.56 Kuechenofen k03 k be ## 162 38.38 kocht k03 k be ## 168 62.43 Karten k03 k be ## 169 36.94 Fahrkarten k03 k be ## 172 46.69 Acker k03 k un ## 176 43.38 kurz k03 k be ## 177 54.75 verkuendet k03 k be ## 178 53.75 kommen k03 k be ## 186 32.56 konnte k03 k un ## 187 41.81 Kaffee k03 k be ## 190 56.81 Broetchenkorb k03 k be ## 191 52.93 keinen k03 k be ## 192 59.88 Kuchen k03 k be ## 195 46.13 einkaufen k03 k be ## 198 29.51 Zucker k03 k un ## 199 43.13 Suessigkeiten k03 k un ## 200 36.75 kaufen k03 k be ## 201 33.82 Konserven k03 k un ## 202 60.69 Kasse k03 k be ## 206 32.25 Kartoffeln k03 k un ## 209 48.00 Kaffee k03 k be ## 211 33.19 Koennen k03 k un ## 213 56.81 Dickicht k03 k un ## 218 65.37 Kuechenofen k03 k be ## 220 40.81 kocht k03 k be Die Zeilen in einem Data Frame sind normalerweise durchnummeriert, d.h. die Zeilen haben einen Index. Wenn wir mittels des Index Zeilen auswählen wollen, nutzen wir slice() bzw. die verwandten Funktionen slice_head(), slice_tail(), slice_min() und slice_max(). Die Funktion slice() bekommt als Argument den Index der auszuwählenden Zeilen: asp %&gt;% slice(4) # Zeile 4 auswählen ## d Wort Vpn Kons Bet ## 4 14.75 Vater k01 t un asp %&gt;% slice(1:10) # die ersten 10 Zeilen auswählen ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un ## 3 26.81 Montag k01 t un ## 4 14.75 Vater k01 t un ## 5 42.38 Tisch k01 t be ## 6 21.56 Mutter k01 t un ## 7 50.00 konnte k01 k un ## 8 78.12 Kaffee k01 k be ## 9 53.63 Tassen k01 t be ## 10 45.94 Teller k01 t be Die Funktionen slice_head() und slice_tail() bekommen als Argument die Anzahl der Zeilen n, die, angefangen bei der ersten bzw. der letzten Zeile, ausgewählt werden sollen. asp %&gt;% slice_head(n = 2) # die ersten zwei Zeilen auswählen ## d Wort Vpn Kons Bet ## 1 26.18 Fruehlingswetter k01 t un ## 2 23.06 Gestern k01 t un asp %&gt;% slice_tail(n = 3) # die letzten drei Zeilen auswählen ## d Wort Vpn Kons Bet ## 2890 24.94 vormittags kko t un ## 2891 21.93 Richtung kko t un ## 2892 51.94 Verkehrt kko k be Die Funktionen slice_min() und slice_max() geben die n Zeilen zurück, die die niedrigsten bzw. höchsten Werte in einer Spalte haben. Wenn n nicht angegeben wird, wird automatisch n = 1 verwendet, es wird also nur eine Zeile zurückgegeben. Weiterführende Infos: Defaults für Argumente Wenn man bestimmte Argumente in Funktionen nicht spezifiziert, werden häufig sog. defaults verwendet. Schauen Sie sich zum Beispiel die Hilfeseite der Funktion seq() an. Dort wird die Funktion mit ihren Argumenten wie folgt aufgeführt: Die Argumente from und to haben den default-Wert 1. Und da dies die einzigen obligatorischen Argumente sind, können Sie die Funktion auch völlig ohne Angabe der Argumente ausführen: seq() ## [1] 1 Auch das Argument by hat einen default-Wert, der anhand der Werte von to, from und length.out berechnet wird, falls der/die NutzerIn keinen anderen Wert eingibt. Meist finden Sie die default-Werte für die Argumente einer Funktion auf der Hilfeseite unter Usage, manchmal stehen die default-Werte auch erst in der Beschreibung der Argumente darunter. Im folgenden zeigen wir Beispiele für die zwei Funktionen, die sich auf die Dauer in Spalte d des Data Frames asp beziehen. asp %&gt;% slice_min(d) # die Zeile auswählen, wo d den niedrigsten Wert hat ## d Wort Vpn Kons Bet ## 1565 5.25 Sonntags k11 t un asp %&gt;% slice_min(d, n = 5) # die fünf Zeilen auswählen, wo d die niedrigsten Werte hat ## d Wort Vpn Kons Bet ## 1565 5.250 Sonntags k11 t un ## 1170 5.690 maechtig K62 t un ## 1548 6.500 Vater k10 t un ## 2507 6.570 unterbrechen k62 t un ## 540 6.688 Mutter k61 t un asp %&gt;% slice_max(d) # die Zeile auswählen, wo d den höchsten Wert hat ## d Wort Vpn Kons Bet ## 2063 138.8 Kiel k70 k be asp %&gt;% slice_max(d, n = 5) # die fünf Zeilen auswählen, wo d die höchsten Werte hat ## d Wort Vpn Kons Bet ## 2063 138.8 Kiel k70 k be ## 2843 129.7 Kiel hpt k be ## 1006 116.5 Ladentuer K23 t be ## 2070 111.6 Tagen k70 t be ## 1456 111.4 kauen k09 k be Diese beiden Funktionen lassen sich sogar auf Spalten anwenden, die Schriftzeichen enthält. In diesem Fall wird alphabetisch vorgegangen. asp %&gt;% slice_min(Wort) # die Zeilen, wo Wort den &quot;niedrigsten&quot; Wert hat ## d Wort Vpn Kons Bet ## 51 47.63 Abteil k01 t be ## 111 56.25 Abteil k02 t be ## 171 56.81 Abteil k03 t be ## 229 31.63 Abteil k04 t be ## 288 67.31 Abteil k04 t be ## 347 76.25 Abteil k05 t be ## 406 38.07 Abteil k05 t be ## 463 52.62 Abteil k06 t be ## 524 46.93 Abteil k61 t be ## 585 35.18 Abteil k61 t be ## 644 47.00 Abteil k62 t be ## 703 79.37 Abteil k63 t be asp %&gt;% slice_max(Wort) # die Zeilen, wo Wort den &quot;höchsten&quot; Wert hat ## d Wort Vpn Kons Bet ## 2444 80.75 zurueckkommen k62 k be ## 2546 73.44 zurueckkommen k62 k be ## 2641 53.30 zurueckkommen dlm k be ## 2743 63.12 zurueckkommen dlm k be ## 2838 79.63 zurueckkommen hpt k be Da es jeweils mehrere Zeilen gibt, wo Wort den niedrigsten (“abkaufen”) bzw. höchsten Wert (“Zwischenstop”) hat, werden all diese Zeilen zurückgegeben (trotz n = 1).` 4.2.2 Selecting Für das Auswählen von Spalten ist die Funktion select() da, die auf verschiedene Art und Weise benutzt werden kann. Als Argumente bekommt diese Funktion die Spaltennamen, die ausgewählt werden sollen. In den folgenden Beispielen sehen Sie außerdem zum ersten Mal, wie man mehrere Funktionen mit einfachen Pipes aneinander hängen kann, denn wir nutzen nach select() hier noch slice(1), damit der Output der Funktionen nicht so lang ist. asp %&gt;% select(Vpn) %&gt;% slice(1) # nur die Spalte Vpn ## Vpn ## 1 k01 asp %&gt;% select(Vpn, Bet) %&gt;% slice(1) # die Spalten Vpn und Bet ## Vpn Bet ## 1 k01 un asp %&gt;% select(d:Kons) %&gt;% slice(1) # die Spalten d bis einschl. Kons ## d Wort Vpn Kons ## 1 26.18 Fruehlingswetter k01 t asp %&gt;% select(!(d:Kons)) %&gt;% slice(1) # alle Spalten außer die Spalten von d bis einschl. Kons ## Bet ## 1 un asp %&gt;% select(-Wort) %&gt;% slice(1) # alle Spalten außer Wort ## d Vpn Kons Bet ## 1 26.18 k01 t un Innerhalb der Funktion select() können die Funktionen starts_with() und ends_with() sehr praktisch sein, wenn Sie alle Spalten auswählen wollen, deren Namen mit demselben Buchstaben oder derselben Buchstabenfolge beginnen bzw. enden. Dies demonstrieren wir anhand des Data Frames vdata, der folgende Spalten hat: vdata %&gt;% colnames() ## [1] &quot;X&quot; &quot;Y&quot; &quot;F1&quot; &quot;F2&quot; &quot;dur&quot; &quot;V&quot; ## [7] &quot;Tense&quot; &quot;Cons&quot; &quot;Rate&quot; &quot;Subj&quot; starts_with() erlaubt es uns, die beiden Spalten F1 und F2 auszuwählen, weil beide mit “F” beginnen: vdata %&gt;% select(starts_with(&quot;F&quot;)) %&gt;% slice(1) ## F1 F2 ## 1 313 966 Wie auch beim Filtern, können Sie mit den logischen Operatoren &amp; bzw. | die Funktionen starts_with() und ends_with() verbinden. Hier wählen wir (auf etwas umständliche Weise) die Spalte F1 aus: vdata %&gt;% select(starts_with(&quot;F&quot;) &amp; !ends_with(&quot;2&quot;)) %&gt;% slice(1) ## F1 ## 1 313 Es wird ab und zu vorkommen, dass wir (nach einer ganzen Reihe an Funktionen) nur eine Spalte ausgegeben haben wollen, aber nicht als Spalte (bzw. um genau zu sein: als Data Frame mit nur einer Spalte), sondern einfach als Vektor. Dafür nutzen wir pull(). Im folgenden Beispiel wählen wir zuerst die ersten zehn Zeilen von asp aus und lassen uns davon dann die Spalte Bet als Vektor ausgeben: asp %&gt;% slice(1:10) %&gt;% pull(Bet) ## [1] &quot;un&quot; &quot;un&quot; &quot;un&quot; &quot;un&quot; &quot;be&quot; &quot;un&quot; &quot;un&quot; &quot;be&quot; &quot;be&quot; &quot;be&quot; An der Ausgabe sehen Sie, dass es sich bei Bet um einen Vektor handelt. 4.2.3 Mutating Mit Mutating können wir Spalten an Data Frames anhängen oder verändern. Der Befehl heißt mutate() und bekommt als Argumente den gewünschten neuen Spaltennamen mit den Werten, die in der Spalte stehen sollen. Wenn mehrere Spalten angelegt werden sollen, können Sie sie innerhalb der Funktion aneinanderreihen. Folgender Code legt zum Beispiel zwei neue Spalten namens F1 und F2 im Data Frame int an: int %&gt;% head() ## Vpn dB Dauer ## 1 S1 24.50 162 ## 2 S2 32.54 120 ## 3 S2 38.02 223 ## 4 S2 28.38 131 ## 5 S1 23.47 67 ## 6 S2 37.82 169 int %&gt;% mutate(F1 = c(282, 277, 228, 270, 313, 293, 289, 380, 293, 307, 238, 359, 300, 318, 231), F2 = c(470, 516, 496, 530, 566, 465, 495, 577, 501, 579, 562, 542, 604, 491, 577)) ## Vpn dB Dauer F1 F2 ## 1 S1 24.50 162 282 470 ## 2 S2 32.54 120 277 516 ## 3 S2 38.02 223 228 496 ## 4 S2 28.38 131 270 530 ## 5 S1 23.47 67 313 566 ## 6 S2 37.82 169 293 465 ## 7 S2 30.08 81 289 495 ## 8 S1 24.50 192 380 577 ## 9 S1 21.37 116 293 501 ## 10 S2 25.60 55 307 579 ## 11 S1 40.20 252 238 562 ## 12 S1 44.27 232 359 542 ## 13 S1 26.60 144 300 604 ## 14 S1 20.88 103 318 491 ## 15 S2 26.05 212 231 577 Diese neuen Spalten werden nicht automatisch im Data Frame abgespeichert! Es gibt zwei Möglichkeiten, um die Spalten dauerhaft an den Data Frame anzuhängen. Die erste ist wie üblich mit dem Zuweisungspfeil. Wir erstellen hier eine neue Variable int_new, die den erweiterten Data Frame enthält; man hätte auch den originalen Data Frame überschreiben können, indem man statt int_new nur int schreibt. int_new &lt;- int %&gt;% mutate(F1 = c(282, 277, 228, 270, 313, 293, 289, 380, 293, 307, 238, 359, 300, 318, 231), F2 = c(470, 516, 496, 530, 566, 465, 495, 577, 501, 579, 562, 542, 604, 491, 577)) int_new %&gt;% head() ## Vpn dB Dauer F1 F2 ## 1 S1 24.50 162 282 470 ## 2 S2 32.54 120 277 516 ## 3 S2 38.02 223 228 496 ## 4 S2 28.38 131 270 530 ## 5 S1 23.47 67 313 566 ## 6 S2 37.82 169 293 465 Die zweite Möglichkeit ist die sogenannte Doppelpipe aus dem Paket magrittr: %&lt;&gt;%. Die Doppelpipe kann nur als erste Pipe in einer Reihe von Pipes eingesetzt werden (auch das werden wir noch sehen). Zudem muss als erstes Argument nach der Doppelpipe nicht mehr der Data Frame stehen, denn der steht schon links von der Doppelpipe. int %&lt;&gt;% mutate(F1 = c(282, 277, 228, 270, 313, 293, 289, 380, 293, 307, 238, 359, 300, 318, 231), F2 = c(470, 516, 496, 530, 566, 465, 495, 577, 501, 579, 562, 542, 604, 491, 577)) int %&gt;% head() ## Vpn dB Dauer F1 F2 ## 1 S1 24.50 162 282 470 ## 2 S2 32.54 120 277 516 ## 3 S2 38.02 223 228 496 ## 4 S2 28.38 131 270 530 ## 5 S1 23.47 67 313 566 ## 6 S2 37.82 169 293 465 Es gibt zwei Funktionen, die sehr hilfreich innerhalb von mutate() sind, wenn eine neue Spalte auf den Werten einer bereits existierenden Spalte beruhen soll. Für binäre Entscheidungen nutzen Sie ifelse(), für nicht binäre Entscheidungen nutzen Sie case_when(). Nehmen wir an, Sie wollen eine weitere Spalte an den Data Frame int anhängen. Sie wissen, dass Versuchsperson “S1” 29 Jahre alt ist, Versuchsperson “S2” ist 33 Jahre alt. Sie wollen eine Spalte age anlegen, die genau das festhält. Dann benutzen Sie die Funktion ifelse() innerhalb von mutate(). ifelse() bekommt als Argumente zuerst einen logischen Ausdruck, dann den Wert, der eingesetzt werden soll, wenn der logische Ausdruck für eine Zeile wahr ist (TRUE), und zuletzt den Wert für Zeilen, für die der logische Ausdruck unwahr ist (FALSE). Um also die neue Spalte zu erstellen, wird für jede Zeile geprüft, ob die Versuchsperson “S1” ist; wenn ja, wird in die neue Spalte age der Wert 29 eingetragen, ansonsten der Wert 33. int %&gt;% mutate(age = ifelse(Vpn == &quot;S1&quot;, 29, 33)) ## Vpn dB Dauer F1 F2 age ## 1 S1 24.50 162 282 470 29 ## 2 S2 32.54 120 277 516 33 ## 3 S2 38.02 223 228 496 33 ## 4 S2 28.38 131 270 530 33 ## 5 S1 23.47 67 313 566 29 ## 6 S2 37.82 169 293 465 33 ## 7 S2 30.08 81 289 495 33 ## 8 S1 24.50 192 380 577 29 ## 9 S1 21.37 116 293 501 29 ## 10 S2 25.60 55 307 579 33 ## 11 S1 40.20 252 238 562 29 ## 12 S1 44.27 232 359 542 29 ## 13 S1 26.60 144 300 604 29 ## 14 S1 20.88 103 318 491 29 ## 15 S2 26.05 212 231 577 33 Bei nicht binären Entscheidungen wird statt ifelse() die Funktion case_when() eingesetzt. Diese Funktion bekommt so viele logische Ausdrücke und entsprechende Werte wie gewünscht. Zum Data Frame int wollen Sie eine weitere Spalte namens noise hinzufügen. Wenn in der Spalte dB ein Wert unter 25 Dezibel steht, soll in der Spalte noise “leise” stehen, bei Dezibelwerten zwischen 25 und 35 soll “mittel” und bei Dezibelwerten über 35 soll “laut” eingetragen werden. Die Schreibweise dieser Bedingungen ist wie folgt: Zuerst kommt der logische Ausdruck, dann die Tilde ~, und abschließend der einzutragende Wert, wenn der logische Ausdruck für eine Zeile wahr ist. int %&gt;% mutate(noise = case_when(dB &lt; 25 ~ &quot;leise&quot;, dB &gt; 25 &amp; dB &lt; 35 ~ &quot;mittel&quot;, dB &gt; 35 ~ &quot;laut&quot;)) ## Vpn dB Dauer F1 F2 noise ## 1 S1 24.50 162 282 470 leise ## 2 S2 32.54 120 277 516 mittel ## 3 S2 38.02 223 228 496 laut ## 4 S2 28.38 131 270 530 mittel ## 5 S1 23.47 67 313 566 leise ## 6 S2 37.82 169 293 465 laut ## 7 S2 30.08 81 289 495 mittel ## 8 S1 24.50 192 380 577 leise ## 9 S1 21.37 116 293 501 leise ## 10 S2 25.60 55 307 579 mittel ## 11 S1 40.20 252 238 562 laut ## 12 S1 44.27 232 359 542 laut ## 13 S1 26.60 144 300 604 mittel ## 14 S1 20.88 103 318 491 leise ## 15 S2 26.05 212 231 577 mittel 4.2.4 Renaming Häufig ist es sinnvoll, Spalten umzubenennen und ihnen vernünftige Namen zu geben. (Generell ist es sinnvoll, den Spalten von Anfang an sprechende Namen zu geben, also Namen, die zweifelsfrei beschreiben, was in der Spalte zu finden ist – dies ist nicht trivial!) Im Data Frame asp sind fast alle Spaltennamen Abkürzungen: asp %&gt;% colnames() ## [1] &quot;d&quot; &quot;Wort&quot; &quot;Vpn&quot; &quot;Kons&quot; &quot;Bet&quot; Jetzt benennen wir die Spalten um und speichern das Ergebnis mittels der Doppelpipe direkt im Data Frame asp ab. Hierzu benutzen wir rename(). Als Argumente bekommt die Funktion zuerst den gewünschten Spaltennamen, dann ein =, und dann den alten Spaltennamen. Sie brauchen die Spaltennamen nicht in Anführungszeichen zu setzen. Wenn Sie gleich mehrere Spalten umbenennen wollen, können Sie das einfach mit Komma getrennt in der Funktion angeben. asp %&lt;&gt;% rename(Dauer = d, Versuchsperson = Vpn, Konsonant = Kons, Betonung = Bet) asp %&gt;% colnames() ## [1] &quot;Dauer&quot; &quot;Wort&quot; &quot;Versuchsperson&quot; ## [4] &quot;Konsonant&quot; &quot;Betonung&quot; 4.3 Weitere Beispiele für komplexe Pipes Wie Sie bereits gesehen haben, lassen sich viele Funktionen mit Pipes aneinanderhängen. Es ist dabei sehr wichtig, sich immer wieder vor Augen zu führen, dass jede Funktion auf das Ergebnis der vorherigen Funktion angewendet wird. Bei langen Pipes sollten Sie außerdem nach jeder Pipe einen Zeilenumbruch einfügen, weil dies die Lesbarkeit erhöht. Die beiden folgenden Schreibweisen haben dasselbe Ergebnis und werfen auch keinen Fehler, aber sie gehen unterschiedlich vor. Im ersten Beispiel wird zuerst die Spalte Versuchsperson ausgewählt, dann wird die erste Zeile ausgewählt, beim zweiten Beispiel genau umgekehrt. asp %&gt;% select(Versuchsperson) %&gt;% slice(1) ## Versuchsperson ## 1 k01 asp %&gt;% slice(1) %&gt;% select(Versuchsperson) ## Versuchsperson ## 1 k01 Das kann unter Umständen zu Fehlern führen, wenn Sie nicht genau aufpassen, in welcher Reihenfolge Sie Funktionen auf einen Data Frame anwenden. Sie möchten zum Beispiel aus dem Data Frame vdata die Spalte X auswählen, aber auch in Alter umbenennen. Dann wird der folgende Code einen Fehler werfen, weil sich die Funktion select() nicht mehr auf die Spalte X anwenden lässt, nachdem die Spalte bereits in Alter umbenannt wurde: vdata %&gt;% rename(Alter = X) %&gt;% select(X) ## Error in `select()`: ## ! Can&#39;t subset columns that don&#39;t exist. ## ✖ Column `X` doesn&#39;t exist. Der Fehler hier sagt Ihnen zum Glück genau, was falsch gelaufen ist. Richtig geht es also so (wir benutzen zusätzlich slice(1:10), damit der Output nicht so lang ist): vdata %&gt;% select(X) %&gt;% rename(Alter = X) %&gt;% slice(1:10) ## Alter ## 1 52.99 ## 2 53.61 ## 3 55.14 ## 4 53.06 ## 5 52.74 ## 6 53.30 ## 7 54.37 ## 8 51.20 ## 9 54.65 ## 10 58.42 Ein weiteres Beispiel. Sie möchten aus dem Data Frame int die Dauerwerte erfahren, wenn F1 unter 270 Hz liegt. int %&gt;% pull(Dauer) %&gt;% filter(F1 &lt; 270) ## Error in UseMethod(&quot;filter&quot;): no applicable method for &#39;filter&#39; applied to an object of class &quot;c(&#39;integer&#39;, &#39;numeric&#39;)&quot; Dieser Fehler ist schon etwas kryptischer. Rekonstruieren wir also, was schief gelaufen ist. Aus dem Data Frame int haben wir die Spalte Dauer gezogen, die auch existiert. Dafür haben wir aber pull() verwendet, und pull() gibt Spalten in Form eines Vektors aus. Wir können das nochmal überprüfen wie folgt: int %&gt;% pull(Dauer) ## [1] 162 120 223 131 67 169 81 192 116 55 252 232 ## [13] 144 103 212 int %&gt;% pull(Dauer) %&gt;% class() ## [1] &quot;integer&quot; Ja, dies ist ein Vektor mit integers. Oben haben wir dann versucht, auf diesen numerischen Vektor eine Funktion anzuwenden, die für Data Frames gedacht ist – daher der Fehler. Die Lösung ist in diesem Fall also, zuerst zu filtern, und dann die Werte ausgeben zu lassen: int %&gt;% filter(F1 &lt; 270) %&gt;% pull(Dauer) ## [1] 223 252 212 Dies sind die Dauerwerte für die drei Zeilen, bei denen F1 unter 270 Hz liegt. Zuletzt wollen wir hier noch ein Beispiel für eine komplexe Pipe mit der Doppelpipe am Anfang zeigen. Was wir also jetzt tun, wird sofort in den Data Frame geschrieben, und nicht einfach in der Konsole ausgegeben. Wir möchten die Spalte noise jetzt dauerhaft im Data Frame int anlegen, dann alle Zeilen auswählen, wo die Versuchsperson “S1” ist und die Dauer zwischen 100 und 200 ms liegt, und zuletzt die Spalten noise und Dauer sowie die ersten fünf Zeilen auswählen. int %&lt;&gt;% mutate(noise = case_when(dB &lt; 25 ~ &quot;leise&quot;, dB &gt; 25 &amp; dB &lt; 35 ~ &quot;mittel&quot;, dB &gt; 35 ~ &quot;laut&quot;)) %&gt;% filter(Vpn == &quot;S1&quot; &amp; Dauer &gt; 100 &amp; Dauer &lt; 200) %&gt;% select(Dauer, noise) %&gt;% slice_head(n = 5) int ## Dauer noise ## 1 162 leise ## 8 192 leise ## 9 116 leise ## 13 144 mittel ## 14 103 leise Der Data Frame int besteht jetzt nur noch aus zwei Spalten und fünf Zeilen, und diese Aktion kann auch nicht rückgängig gemacht werden. Seien Sie also vorsichtig und überlegen Sie genau, ob Sie einen Data Frame mit dem Ergebnis einer Pipe überschreiben wollen. "],["summary-statistics.html", "5 Summary Statistics 5.1 Mittelwert &amp; Median 5.2 Varianz &amp; Standardabweichung 5.3 Quantile 5.4 Beispiel Boxplot", " 5 Summary Statistics Für dieses Kapitel benötigen Sie die folgenden Packages und den folgenden Data Frame: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) Wenn man sich einen Überblick über Daten verschaffen möchte, sind sogenannte summary statitics (deskriptive Statistiken) häufig hilfreich. Zu solchen deskriptiven Werten zählen z.B. das arithmetische Mittel (Mittelwert), Median, Varianz, Standardabweichung, Minimum, Maximum, usw. Hier zeigen wir zunächst wie man solche Werte ohne Funktionen aus dem tidyverse berechnen kann. Da R eine Statistik-Software ist, sind solche Basis-Funktionen wie zur Berechnung des Mittelwerts immer verfügbar. Im Folgenden demonstrieren wir die wichtigsten Funktionen zur Berechnung von summary statistics anhand der F1-Werte in vdata: mean(vdata$F1) # arithmetisches Mittel ## [1] 407.3 median(vdata$F1) # Median ## [1] 366 var(vdata$F1) # Varianz ## [1] 21255 sd(vdata$F1) # Standardabweichung ## [1] 145.8 min(vdata$F1) # Minimum ## [1] 0 max(vdata$F1) # Maximum ## [1] 1114 range(vdata$F1) # Minimum &amp; Maximum ## [1] 0 1114 quantile(vdata$F1, 0.25) # 1. Quartil ## 25% ## 300 quantile(vdata$F1, 0.75) # 3. Quartil ## 75% ## 509.8 IQR(vdata$F1) # interquartiler Bereich ## [1] 209.8 5.1 Mittelwert &amp; Median Das arithmetische Mittel wird berechnet, indem man die Summe einer Anzahl \\(n\\) an Zahlen bildet, und diese Summe dann durch die Anzahl \\(n\\) teilt. Hier ist ein sehr einfaches Beispiel: zahlen &lt;- 1:5 summe &lt;- sum(zahlen) summe ## [1] 15 anzahl &lt;- length(zahlen) anzahl ## [1] 5 # Mittelwert: summe/anzahl ## [1] 3 # zum Vergleich: mean(zahlen) ## [1] 3 Der Median hingegen ist die mittig liegende Zahl in einer sortierten Zahlenreihe. Nehmen wir wieder obiges Beispiel (die Zahlen sind bereits aufsteigend sortiert): zahlen ## [1] 1 2 3 4 5 median(zahlen) ## [1] 3 Bei einer geraden Anzahl von Zahlen berechnet man den Median als den Mittelwert der zwei mittig liegenden Werte, zum Beispiel: zahlen &lt;- 1:6 median(zahlen) ## [1] 3.5 mean(c(3, 4)) ## [1] 3.5 Der Median ist robuster gegen sogenannte Ausreißer (engl. outlier) als der Mittelwert. Ausreißer sind Datenpunkte, die deutlich extremer sind als die Mehrheit der Datenpunkte. Hier wieder ein einfaches Beispiel: zahlen &lt;- c(1:5, 100) zahlen ## [1] 1 2 3 4 5 100 mean(zahlen) ## [1] 19.17 median(zahlen) ## [1] 3.5 Die Zahl 100 ist ganz offensichtlich ein Ausreißer im Vektor zahlen. Der Mittelwert ist wegen dieses Ausreißers jetzt um ein Vielfaches höher als vorher, während der Median sich nur leicht verändert hat. 5.2 Varianz &amp; Standardabweichung Varianz und Standardabweichung sind verwandte Maße für die Streuung von Werten um ihren Mittelwert. Genauer gesagt ist die Varianz die Summe der quadrierten Abweichungen der Messwerte von ihrem Mittelwert geteilt durch die Anzahl der Messwerte minus 1, während die Standardabweichung die Quadratwurzel der Varianz ist. Am folgenden Beispiel können Sie nachvollziehen, wie man die Varianz und Standardabweichung “händisch” berechnet: zahlen &lt;- c(12, 6, 24, 3, 17) # Mittelwert m &lt;- mean(zahlen) m ## [1] 12.4 # quadrierte Abweichungen quadr_abw &lt;- (zahlen - m)^2 quadr_abw ## [1] 0.16 40.96 134.56 88.36 21.16 # Anzahl der Messwerte n &lt;- length(zahlen) n ## [1] 5 # Summe der quadrierten Abweichungen summe &lt;- sum(quadr_abw) summe ## [1] 285.2 # Varianz: varianz &lt;- summe / (n - 1) varianz ## [1] 71.3 # Mit der Funktion var(): var(zahlen) ## [1] 71.3 Um jetzt die Standardabweichung daraus zu berechnen, die in der Statistik viel häufiger verwendet wird als die Varianz, brauchen wir nur noch die Quadratwurzel aus der Varianz zu ziehen: std_abw &lt;- sqrt(varianz) std_abw ## [1] 8.444 # oder mit sd() sd(zahlen) ## [1] 8.444 5.3 Quantile Ein Quantil teilt Datenpunkte so auf, dass ein bestimmter Teil der Datenpunkte unterhalb des Quantils liegen. Quantil ist ein Überbegriff; je nachdem in wie viele Stücke man die Datenpunkte aufteilt, sagt man auch Perzentil (100 Stücke) oder Quartil (4 Stücke). Der Median ist ebenfalls ein Quantil, denn 50% der Daten liegen immer unter dem Median. In R berechnet die Funktion quantile() die Quantile. Die Funktion bekommt zuerst die Datenpunkte (also einen numerischen Vektor) und anschließend die Proportion der Datenpunkte, die unter dem zu berechnenden Wert liegen soll. Wichtige Quantile sind das erste und dritte Quartil, also die Schwellwerte, unter denen ein Viertel bzw. drei Viertel aller Datenpunkte liegen. quantile(vdata$F1, 0.25) # 1. Quartil ## 25% ## 300 quantile(vdata$F1, 0.75) # 3. Quartil ## 75% ## 509.8 IQR(vdata$F1) # interquartiler Bereich ## [1] 209.8 Die Differenz zwischen dem ersten und dritten Quartil wird auch interquartiler Bereich oder Interquartilsabstand (interquartile range) genannt und kann mit der Funktion IQR() berechnet werden. 5.4 Beispiel Boxplot Ein Boxplot enthält viele der deskriptiven Informationen, die wir bis jetzt behandelt haben: Median: Der Strich innerhalb der Box ist der Median. Box: Die Box umfasst die mittleren 50% aller Datenpunkte. Das untere Ende der Box ist das erste Quartil (Q1), das obere Ende ist das dritte Quartil (Q3). Das heißt die Box ist genauso groß wie der Interquartilsabstand. Whiskers: Die Whiskers erstrecken sich vom Q1 und vom Q3 aus zu dem niedrigsten/höchsten Datenpunkt, der innerhalb von 1.5 * IQR liegt. Diese Berechnung der Länge der Whiskers als 1.5 * IQR gilt für Boxplots, die mit ggplot2 erstellt wurden, aber nicht jeder Boxplot wird so berechnet. Punkte: Ausreißer, also alle restlichen Datenpunkte, die nicht in der Box und den Whiskers enthalten sind. Hier sehen Sie den Boxplot für F1 aus dem Data Frame vdata: Wie man diesen Boxplot erstellt, erfahren Sie später in diesem Kurs. "],["daten-manipulieren-mit-dplyr-fortsetzung.html", "6 Daten manipulieren mit dplyr (Fortsetzung) 6.1 Grouping &amp; Summarising 6.2 Arranging", " 6 Daten manipulieren mit dplyr (Fortsetzung) 6.1 Grouping &amp; Summarising Laden Sie die folgenden Libraries und Data Frames: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) coronal &lt;- read.table(file.path(url, &quot;coronal.txt&quot;)) vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) In Kapitel 5 haben wir summary statistics für F1-Werte aus dem Data Frame vdata berechnet. Natürlich geht das auch innerhalb der tidyverse-Syntax, nämlich mit der Funktion summarise() aus dem Package dplyr. Diese Funktion verändert den Data Frame grundlegend, denn die ursprünglichen Daten werden zu neuen Werten zusammengefasst. Dies betrifft sowohl die Anzahl der Spalten als auch der Anzahl der Zeilen. summarise() erstellt neue Spalten und keine der originalen Spalten werden beibehalten. Die Funktion bekommt als Argument also den/die neuen Spaltennamen und wie die Werte in dieser neuen Spalte berechnet werden sollen: vdata %&gt;% summarise(mittelwert = mean(F1)) ## mittelwert ## 1 407.3 Der Output dieser Pipe ist ein Data Frame mit nur einer Spalte und einer Zeile. Wir können aber auch mehrere deskriptive Werte gleichzeitig berechnen und erhalten dadurch mehr Spalten: vdata %&gt;% summarise(mittelwert = mean(F1), std_abw = sd(F1), summe = sum(F1), maximum = max(F1), Q1 = quantile(F1, 0.25)) ## mittelwert std_abw summe maximum Q1 ## 1 407.3 145.8 1214532 1114 300 Die Funktionen mutate() und summarise() haben also gemein, dass sie neue Spalten erstellen; während in mutate() aber alle ursprünglichen Zeilen und Spalten erhalten bleiben, erstellt summarise() einen ganz neuen Data Frame mit deutlich weniger Zeilen als ursprünglich vorhanden waren (denn hier wurden Werte zusammengefasst). Was würden Sie jetzt tun, wenn Sie den F1-Mittelwert für nur einen bestimmten Vokal V aus dem Data Frame berechnen wollen? Vermutlich würden Sie dies wie folgt lösen (für den Vokal V == \"E\"): vdata %&gt;% filter(V == &quot;E&quot;) %&gt;% summarise(mittelwert = mean(F1)) ## mittelwert ## 1 426.2 Der F1-Mittelwert für “E” ist also ca. 426 Hz. Wenn Sie sich für die vokalspezifischen F1-Mittelwerte interessieren, dann ist es nicht mehr sinnvoll, für jeden einzelnen Vokal den obigen Code zu benutzen. Stattdessen gibt es die Funktion group_by(). group_by() bekommt als Argumente alle Spalten, nach denen gruppiert werden soll. summarise() berechnet die gewünschten summary statistics anschließend pro Gruppe. In unserem Beispiel gruppieren wir nach Vokal und berechnen dann den Mittelwert pro Vokal: vdata %&gt;% group_by(V) %&gt;% summarise(mittelwert = mean(F1)) ## # A tibble: 7 × 2 ## V mittelwert ## &lt;chr&gt; &lt;dbl&gt; ## 1 % 424. ## 2 A 645. ## 3 E 426. ## 4 I 311. ## 5 O 434. ## 6 U 304. ## 7 Y 302. Es wurden zwei Spalten erstellt: Die eine enthält die sieben verschiedenen Vokale aus dem originalen Data Frame, die andere die vokalspezifischen F1-Mittelwerte. Sie können natürlich auch nach mehr als einer Spalte gruppieren. Es ist zum Beispiel anzunehmen, dass sich der mittlere F1 nicht nur von Vokal zu Vokal unterscheidet, sondern dass auch der Gespanntheitsgrad Tense einen Einfluss hat. Deshalb gruppieren wir nach Vokal und Gespanntheitsgrad und berechnen dann den mittleren F1: vdata %&gt;% group_by(V, Tense) %&gt;% summarise(mittelwert = mean(F1)) ## `summarise()` has grouped output by &#39;V&#39;. You can ## override using the `.groups` argument. ## # A tibble: 14 × 3 ## # Groups: V [7] ## V Tense mittelwert ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 % + 368. ## 2 % - 479. ## 3 A + 668. ## 4 A - 622. ## 5 E + 363. ## 6 E - 488. ## 7 I + 276. ## 8 I - 346. ## 9 O + 348. ## 10 O - 520. ## 11 U + 259. ## 12 U - 348. ## 13 Y + 266. ## 14 Y - 338. Wir sehen jetzt also den F1-Mittelwert für nicht gespannte “%”, gespannte “%” (ignorieren Sie die seltsame Vokal-Kodierung), nicht gespannte “A”, gespannte “A”, usw. Weiterführende Infos: summarise() warning Oben sehen Sie eine Warnmeldung, die von summarise() geworfen wurde. Warnmeldungen sind dazu da, Sie auf etwas aufmerksam zu machen – Sie sollten sie also nicht ignorieren. Diese Warnmeldung zeigt erstmal an, dass das Ergebnis des Codes ein gruppierter Data Frame ist (Objektklasse grouped_df) und dass die Gruppierungsvariable V ist: vdata %&gt;% group_by(V, Tense) %&gt;% summarise(mittelwert = mean(F1)) %&gt;% class() ## `summarise()` has grouped output by &#39;V&#39;. You can ## override using the `.groups` argument. ## [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Die Warnmeldung zeigt außerdem, dass man die Gruppierung des Ergebnisses auch verändern kann, indem man das summarise()-Argument .groups verwendet. Dieses Argument kann verschiedene Werte annehmen, wie Sie auf der Hilfsseite der Funktion summarise() nachlesen können. Bei den vorherigen Code Snippets, bei denen wir group_by() im Zusammenspiel mit summarise() verwendet haben, ist die Warnmeldung übrigens deshalb nicht aufgetaucht, weil wir nur nach einer Variable gruppiert haben; im Ergebnis wird diese Gruppierung automatisch aufgehoben. Es ist wichtig zu verstehen, dass nur nach kategorialen Spalten gruppiert werden kann. Es ergibt keinen Sinn, nach nicht-kategorialen numerischen Spalten zu gruppieren, denn hier gibt es keine Gruppen (jeder Wert ist vermutlich einzigartig). Der Sinn von summarise() ist es aber ja gerade, deskriptive Statistiken für kategoriale Gruppen zu berechnen. Zuletzt wollen wir noch die Funktionen n() und n_distinct() vorstellen. n() benötigt keine Argumente und wird nach group_by() innerhalb summarise() verwendet, um die Anzahl an Beobachtungen (Zeilen) pro Gruppe zurückzugeben. n_distinct() bekommt als Argument den Namen einer Spalte und findet heraus, wie viele unterschiedliche (einzigartige) Werte einer Variable es pro Gruppe gibt. # Anzahl an Zeilen für jede Kombination von V und Tense vdata %&gt;% group_by(V, Tense) %&gt;% summarise(count = n()) ## `summarise()` has grouped output by &#39;V&#39;. You can ## override using the `.groups` argument. ## # A tibble: 14 × 3 ## # Groups: V [7] ## V Tense count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 % + 212 ## 2 % - 214 ## 3 A + 214 ## 4 A - 218 ## 5 E + 210 ## 6 E - 215 ## 7 I + 210 ## 8 I - 214 ## 9 O + 214 ## 10 O - 214 ## 11 U + 208 ## 12 U - 215 ## 13 Y + 211 ## 14 Y - 213 # Anzahl der einzigartigen Sprecher pro Region und sozialer Klasse coronal %&gt;% group_by(Region, Socialclass) %&gt;% summarise(count = n_distinct(Vpn)) ## `summarise()` has grouped output by &#39;Region&#39;. You can ## override using the `.groups` argument. ## # A tibble: 9 × 3 ## # Groups: Region [3] ## Region Socialclass count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 R1 LM 40 ## 2 R1 UM 30 ## 3 R1 W 11 ## 4 R2 LM 26 ## 5 R2 UM 18 ## 6 R2 W 36 ## 7 R3 LM 22 ## 8 R3 UM 31 ## 9 R3 W 26 Weiterführende Infos: Funktionen eindeutig beschreiben Da die Funktionen aus dem tidyverse, insbesonderen aus dplyr, sehr gängige Namen haben (filter(), summarise(), rename()), werden sie leicht von Funktionen mit demselben Namen aus anderen Paketen maskiert. Wenn Sie also von einer dieser Funktionen einen Fehler bekommen, laden Sie entweder noch einmal das Paket, aus dem die Funktion stammen soll (z.B. library(dplyr)), oder nutzen Sie die folgende Schreibweise: dplyr::filter(). 6.2 Arranging In der alltäglichen Arbeit mit Data Frames kann es sinnvoll sein, den Data Frame nach Zeilen oder Spalten zu ordnen. Für das Ordnen der Zeilen wird arrange() benutzt, für das Ordnen der Spalten relocate(). Hier ordnen wir den Data Frame int aufsteigend nach Dauer: int %&gt;% arrange(Dauer) ## Vpn dB Dauer ## 10 S2 25.60 55 ## 5 S1 23.47 67 ## 7 S2 30.08 81 ## 14 S1 20.88 103 ## 9 S1 21.37 116 ## 2 S2 32.54 120 ## 4 S2 28.38 131 ## 13 S1 26.60 144 ## 1 S1 24.50 162 ## 6 S2 37.82 169 ## 8 S1 24.50 192 ## 15 S2 26.05 212 ## 3 S2 38.02 223 ## 12 S1 44.27 232 ## 11 S1 40.20 252 arrange() kann auch alphabetisch oder nach mehreren Spalten ordnen: int %&gt;% arrange(Vpn, Dauer) ## Vpn dB Dauer ## 5 S1 23.47 67 ## 14 S1 20.88 103 ## 9 S1 21.37 116 ## 13 S1 26.60 144 ## 1 S1 24.50 162 ## 8 S1 24.50 192 ## 12 S1 44.27 232 ## 11 S1 40.20 252 ## 10 S2 25.60 55 ## 7 S2 30.08 81 ## 2 S2 32.54 120 ## 4 S2 28.38 131 ## 6 S2 37.82 169 ## 15 S2 26.05 212 ## 3 S2 38.02 223 Um absteigend zu ordnen, wird desc() (descending) innerhalb von arrange() genutzt: int %&gt;% arrange(Vpn, desc(Dauer)) ## Vpn dB Dauer ## 11 S1 40.20 252 ## 12 S1 44.27 232 ## 8 S1 24.50 192 ## 1 S1 24.50 162 ## 13 S1 26.60 144 ## 9 S1 21.37 116 ## 14 S1 20.88 103 ## 5 S1 23.47 67 ## 3 S2 38.02 223 ## 15 S2 26.05 212 ## 6 S2 37.82 169 ## 4 S2 28.38 131 ## 2 S2 32.54 120 ## 7 S2 30.08 81 ## 10 S2 25.60 55 relocate() bekommt als Argumente die Namen aller Spalten, die umsortiert werden sollen. Wenn sonst keine weiteren Argumente angegeben werden, werden die Spalten an den Anfang des Data Frames gesetzt. Ansonsten können die Argumente .before und .after verwendet werden, um anzugeben, vor oder nach welche Spalten die anderen Spalten gesetzt werden sollen: vdata %&gt;% slice(1) ## X Y F1 F2 dur V Tense Cons Rate Subj ## 1 52.99 4.36 313 966 106.9 % - P a bk vdata %&gt;% relocate(Subj) %&gt;% slice(1) ## Subj X Y F1 F2 dur V Tense Cons Rate ## 1 bk 52.99 4.36 313 966 106.9 % - P a vdata %&gt;% relocate(Subj, Cons) %&gt;% slice(1) ## Subj Cons X Y F1 F2 dur V Tense Rate ## 1 bk P 52.99 4.36 313 966 106.9 % - a vdata %&gt;% relocate(where(is.numeric), .after = Subj) %&gt;% slice(1) ## V Tense Cons Rate Subj X Y F1 F2 dur ## 1 % - P a bk 52.99 4.36 313 966 106.9 vdata %&gt;% relocate(where(is.character), .before = dur) %&gt;% slice(1) ## X Y F1 F2 V Tense Cons Rate Subj dur ## 1 52.99 4.36 313 966 % - P a bk 106.9 "],["daten-abbilden-mit-ggplot2.html", "7 Daten abbilden mit ggplot2 7.1 Boxplots 7.2 Scatter- &amp; Lineplots 7.3 Barplots 7.4 Histogramme &amp; Wahrscheinlichkeitsdichte", " 7 Daten abbilden mit ggplot2 Laden Sie dann die folgenden Packages und Data Frames: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) coronal &lt;- read.table(file.path(url, &quot;coronal.txt&quot;)) vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) ggplot2 ist eine Library aus dem tidyverse, die Ihnen sehr viele Möglichkeiten für die Visualisierung von Daten liefert. gg steht für grammar of graphics. Der Befehl, mit dem Sie eine Abbildung beginnen, ist ggplot(); das Hauptargument dieser Funktion ist der gewünschte Data Frame. Dann fügt man das sog. aesthetic mapping mittels aes(), sowie Funktionen für die Art der Abbildung, die Beschriftungen, die Legende, etc., hinzu. Jede Funktion wird mit + verbunden (nicht mit Pipes!). 7.1 Boxplots Boxplots sind die wohl wichtigsten wissenschaftlich genutzten Abbildungen. In R werden sie mit dem Befehl geom_boxplot() erstellt. Zuerst zeigen wir, wie der Boxplot in Kapitel 5.4 erstellt wurde. Die Funktion ggplot() bekommt den Data Frame vdata. In den aesthetic mappings aes() tragen wir ein, dass F1 auf der y-Achse aufgetragen werden soll. Zuletzt bestimmen wir noch, dass ein Boxplot gezeichnet werden soll. ggplot(vdata) + aes(y = F1) + geom_boxplot() Boxplots eignen sich sehr gut zum Vergleichen von Werten für verschiedene kategoriale Gruppen. Dann werden diese Gruppen (üblicherweise) auf der x-Achse aufgetragen und auf der y-Achse wieder die gewünschten Werte. Hier sehen Sie ein Beispiel für die Dauer verschiedener Konsonanten aus dem Data Frame asp: ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() Boxplots können auch horizontal erstellt werden (wobei das meist weniger übersichtlich ist). Dann werden die Kategorien auf der y-Achse und die Werte auf der x-Achse aufgetragen: ggplot(asp) + aes(x = d, y = Kons) + geom_boxplot() Manchmal ist ein sogenannter Notch gewünscht; dafür nutzen wir das Argument notch = TRUE in der Funktion geom_boxplot() (und ggf. notchwidth, um die Tiefe des Notches anzupassen): ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot(notch = TRUE) ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot(notch = TRUE, notchwidth = 0.3) Weiterführende Infos: Aesthetic mappings &amp; Piping Data Frames Streng genommen sind die aesthetic mappings immer ein Argument der Funktion, die über die Art des Plots bestimmt (also z.B. geom_boxplot()). Später werden Sie feststellen, dass manche Plots bestimmte aesthetic mappings benötigen bzw. zulassen, die andere Plots nicht verarbeiten können. Wir lagern die aesthetic mappings in den allermeisten Fällen aus der Plot-Funktion aus, weil das übersichtlicher ist. Es steht Ihnen aber frei, die aesthetic mappings in die Funktion als Argument reinzuschreiben: ggplot(asp) + geom_boxplot(aes(x = Kons, y = d), notch = TRUE, notchwidth = 0.3) Innerhalb eines ggplot werden die einzelnen Funktion immer und ausschließlich mit einem Pluszeichen verbunden. Der Data Frame allerdings kann mit einer einfachen Pipe an ggplot()übergeben werden: asp %&gt;% ggplot() + aes(x = Kons, y = d) + geom_boxplot() Das ist besonders hilfreich, wenn Sie vor dem Plotten erst noch weitere Funktionen auf den Data Frame anwenden wollen, bevor Sie die daraus entstehenden Daten plotten. Hier filtern wir zum Beispiel zuerst nach Betonung, bevor wir anschließend nur noch die Dauer der betonten Wörter plotten: asp %&gt;% filter(Bet == &quot;be&quot;) %&gt;% ggplot() + aes(x = Kons, y = d) + geom_boxplot() 7.2 Scatter- &amp; Lineplots Scatterplots werden mit den Funktionen geom_point() und/oder geom_line() erstellt. Man kann auch beide Funktionen gleichzeitig verwenden. Auf die x- und y-Achse werden üblicherweise nur numerisch-kontinuierliche Daten aufgetragen. Im Folgenden plotten wir zum Beispiel Lautstärke in Dezibel gegen Dauer in Millisekunden. # Punkte: ggplot(int) + aes(x = Dauer, y = dB) + geom_point() # Linie: ggplot(int) + aes(x = Dauer, y = dB) + geom_line() # Beides: ggplot(int) + aes(x = Dauer, y = dB) + geom_line() + geom_point() Manchmal ist es hilfreich, vertikale oder horizontale Referenzlinien in einem Plot einzuzeichnen. Horizontale Linien werden mit geom_hline() erzeugt, vertikale gerade Linien mit geom_vline(). Um eine horizontale Linie zu zeichnen, muss bekannt sein, an welcher Stelle die Linie die y-Achse schneidet. Deshalb bekommt geom_hline() immer das Argument yintercept. Bei geom_vline() muss mit xintercept die Schnittstelle der vertikalen Linie mit der x-Achse eingetragen werden. Wir fügen zum obigen Scatterplot zwei gerade Linien hinzu: ggplot(int) + aes(x = Dauer, y = dB) + geom_point() + geom_vline(xintercept = 150) + geom_hline(yintercept = 35) 7.3 Barplots Eine weitere wichtige Abbildungsform sind Barplots, die mit geom_bar() erzeugt werden. Dabei darf nur entweder x oder y in den aesthetic mappings verwendet werden. Das liegt daran, dass auf die jeweils andere Achse grundsätzlich ein count oder eine Proportion aufgetragen wird, die von ggplot berechnet wird. Der folgende Plot zeigt zum Beispiel, wie viele Vorkommnisse dreier Regionen im Data Frame coronal zu finden sind. ggplot(coronal) + aes(x = Region) + geom_bar() Die Balken können wir auch horizontal plotten, indem wir in den aesthetic mappings y statt x angeben: ggplot(coronal) + aes(y = Region) + geom_bar() Die Werte der Balken können Sie ganz einfach nachvollziehen, indem Sie sich die Anzahl der Vorkommnisse der drei Regionen mittels der Funktion table() anzeigen lassen: table(coronal$Region) ## ## R1 R2 R3 ## 81 80 79 Beim Barplot können Sie aber wie z.B. beim Boxplot noch eine weitere (kategoriale) Variable plotten. Die zweite Variable, die abgebildet werden soll, wird mit dem Argument fill angegeben, das die Levels der Variable als Füllfarben darstellt. Sie werden nächste Woche u.a. lernen, wie man Farben selbst bestimmen kann. Im Folgenden sieht man, wie häufig die Frikative Fr “s” (rot) und “sh” (blau) jeweils in den drei Regionen produziert wurden. ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar() Lassen Sie uns mittels der zuvor gelernten Funktionen für Grouping und Summarising die Werte in diesem Plot nachvollziehen. Dafür gruppieren wir nach Region und Frikativ und lassen uns dann mit n() innerhalb von summarise() die Anzahl der Zeilen im Data Frame pro Gruppenkombination bestimmen. coronal %&gt;% group_by(Region, Fr) %&gt;% summarise(count = n()) ## `summarise()` has grouped output by &#39;Region&#39;. You can ## override using the `.groups` argument. ## # A tibble: 6 × 3 ## # Groups: Region [3] ## Region Fr count ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 R1 s 58 ## 2 R1 sh 23 ## 3 R2 s 59 ## 4 R2 sh 21 ## 5 R3 s 66 ## 6 R3 sh 13 Die Funktion geom_bar() kann als Argument noch position bekommen… # ...um Proportionen anstatt einer absoluten Anzahl darzustellen: ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar(position = &quot;fill&quot;) # ...um die Balken nebeneinander zu stellen: ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar(position = &quot;dodge&quot;) 7.4 Histogramme &amp; Wahrscheinlichkeitsdichte Histogramme zeigen die Verteilung von numerisch-kontinuierlichen Datenpunkten, indem sie den Wertebereich in mehrere kleine Bereiche einteilt. Ähnlich wie beim Barplot zeigen dann Balken (bins) an, wie viele Werte in einem bestimmten Wertebereich liegen. In ggplot werden Histogramme mit geom_histogram() erstellt. In den aesthetic mappings legen wir mit dem Argument x fest, welche Daten wir anschauen wollen, zum Beispiel die F1-Verteilung: ggplot(vdata) + aes(x = F1) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. Um die einzelnen Balken besser voneinander unterscheiden zu können, lassen wir die Balken weiß umranden, indem wir geom_histogram() das Argument color = \"white\" übergeben: ggplot(vdata) + aes(x = F1) + geom_histogram(color = &quot;white&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. Wir können auch selbst bestimmen, wie breit die Balken sein sollen, nämlich mit binwidth. Im Moment umfasst ein Balken ca. 40 Hz. Die folgenden Abbildungen zeigen die exakt selben Daten, aber mit Balken von 10 Hz und Balken von 100 Hz: ggplot(vdata) + aes(x = F1) + geom_histogram(color = &quot;white&quot;, binwidth = 10) ggplot(vdata) + aes(x = F1) + geom_histogram(color = &quot;white&quot;, binwidth = 100) Sie sehen, dass dies für die Repräsentation der Daten einen großen Unterschied macht – gehen Sie also immer mit Bedacht vor, wenn Sie die binwidth von Histogrammen verändern. Mit dem Histogramm verwandt ist die Wahrscheinlichkeitsdichte (engl. probability density). Die einzige Änderung, die wir dafür vornehmen müssen, ist aes() das Argument y = ..density.. zu übergeben. Dies verändert die y-Achse so, dass statt der Anzahl an Datenpunkten die Wahrscheinlichkeitsdichte der Datenpunkte angezeigt wird. Per definitionem ist die Fläche unter den Balken der Wahrscheinlichkeitsdichte insgesamt 1. ggplot(vdata) + aes(x = F1, y = ..density..) + geom_histogram(color = &quot;white&quot;, binwidth = 100) ## Warning: The dot-dot notation (`..density..`) was deprecated in ## ggplot2 3.4.0. ## ℹ Please use `after_stat(density)` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see ## where this warning was generated. Die Wahrscheinlichkeitsdichte wird berechnet als count / (n * binwidth), wo n die Anzahl aller Datenpunkte ist. In dem Histogramm oben (mit binwidth = 100) liegen zum Beispiel 285 Datenpunkte (count) im Wertebereich zwischen 150 Hz und 250 Hz. Die Wahrscheinlichkeitsdichte für diesen Balken wird also wie folgt berechnet: count &lt;- 285 n &lt;- nrow(vdata) binwidth &lt;- 100 dens &lt;- count / (n * binwidth) dens ## [1] 0.0009557 Dieser Wert stimmt mit dem density-Wert überein, den wir in der Wahrscheinlichkeitsdichteverteilung für denselben Balken sehen. Die Fläche dieses Balkens in der Wahrscheinlichkeitsdichteverteilung wird berechnet als binwidth * binheight: area &lt;- binwidth * dens area ## [1] 0.09557 Wenn man die Fläche aller Balken berechnet und summiert, ist die Gesamtfläche 1. Stellen Sie sich nun ein Wahrscheinlichkeitsdichte-Histogramm vor, das aus unendlich vielen Balken besteht (die dementsprechend unendlich schmal sein müssen). Sie erhalten nicht mehr einzelne Balken sondern eine kontinuierliche Funktion, die sich Wahrscheinlichkeitsdichteverteilung (probability density function) nennt. Auch dafür kennt ggplot2 eine Funktion: geom_density(). ggplot(vdata) + aes(x = F1) + geom_density() Hier gilt genau wie bei dem Histogramm mit der Wahrscheinlichkeitsdichte, dass das Integral (die Fläche) unter der Kurve 1 ist. Weiterführende Infos: Histogramme und Probability Density Für weitere Informationen schauen Sie sich gerne Wilke’s Fundamentals of Data Visualization in R, Kapitel 7 an. "],["daten-aufräumen-mit-tidyr.html", "8 Daten aufräumen mit tidyr 8.1 Tibbles 8.2 Pivoting 8.3 Separating", " 8 Daten aufräumen mit tidyr Laden Sie die folgenden Packages und Data Frames: library(tidyverse) library(magrittr) library(gridExtra) ## ## Attaching package: &#39;gridExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## combine url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) avokal &lt;- read.table(file.path(url, &quot;avokal.txt&quot;)) vcv &lt;- read.table(file.path(url, &quot;vcvC.txt&quot;)) “tidy datasets are all alike but every messy dataset is messy in its own way” – Hadley Wickham Hadley Wickham ist der Chef-Entwickler des tidyverse. Die Funktionen des tidyverse sind nicht nur auf Datenmanipulation und -verarbeitung ausgerichtet, sondern auch auf das Aufräumen von Datensätzen. Ein aufgeräumter Datensatz folgt drei Prinzipien: Jede Spalte enthält eine Variable Jede Zeile enthält eine Beobachtung Jede Zelle enthält einen Wert Diese Grundsätze scheinen zunächst offensichtlich, werden Ihnen aber in der täglichen Arbeit mit Daten in R immer wieder begegnen. Die drei Prinzipien sollten Sie vor allem aus zwei Gründen befolgen: Erstens ist jeder Datensatz so auf dieselbe konsistente Weise strukturiert, was Ihnen jede Analyse erleichtern wird. Zweitens sind die Funktionen in R, aber insbesondere die Funktionen des tidyverse auf die Arbeit mit Spalten ausgelegt. Das heißt, Sie wenden Funktionen häufig auf einzelne Spalten an. Deshalb ist es sinnvoll, wenn jede Spalte eine Variable enthält. Um dies zu verdeutlichen, zeigen wir Ihnen im Folgenden Beispiele für die zwei häufigsten Arten von messy data. Spaltennamen sind nicht Variablen, sondern Werte: Die Spalten schnell und langsam im Data Frame avokal sind eigentlich Werte der Variable Tempo. avokal ## schnell langsam Vpn ## 1 430 415 S1 ## 2 266 238 S2 ## 3 567 390 S3 ## 4 531 410 S4 ## 5 707 605 S5 ## 6 716 609 S6 ## 7 651 632 S7 ## 8 589 523 S8 ## 9 469 411 S9 ## 10 723 612 S10 Mehrere Variablen sind in einer Spalte gespeichert: In der Spalte Context sind zwei Informationen abgespeichert: der linke und der rechte phonetische Kontext. Besser ist die Aufteilung in zwei Spalten, die sogar auch schon im Data Frame existieren (Left und Right). vcv %&gt;% head() ## RT Subject Vowel Lang Left Right Context ## 361 647.5 S209 a AE f h f.h ## 362 617.0 S209 a AE f sh f.sh ## 363 728.5 S209 a AE f sh f.sh ## 364 629.0 S209 a AE f th f.th ## 365 688.5 S209 a AE f th f.th ## 366 602.5 S209 a AE s h s.h Es ist nicht trivial, einen Data Frame sauber zu strukturieren. Nur ein Beispiel: Sie haben die ersten vier Formanten in Vokalen gemessen. Ist es sinnvoller, die erhobenen Daten in vier Spalten F1, F2, F3, F4 festzuhalten? Oder besser in zwei Spalten Hz (mit den Formantwerten in Hertz) und Formant (mit den Werten 1, 2, 3 oder 4)? Bevor wir Ihnen zeigen, wie Sie die obigen Datensätze so umformen können, dass sie den drei Prinzipien für aufgeräumte Daten folgen, möchten wir Ihnen noch die tibble vorstellen. 8.1 Tibbles Die tibble ist eine vereinfachte Form eines Data Frames, die im tidyverse häufig verwendet wird. Wir laden hier einen weiteren Data Frame und formen ihn danach mittels as_tibble() um: vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) %&gt;% as_tibble() Wenn wir den Namen der tibble jetzt in die Konsole eingeben, wird nicht wie beim Data Frame üblich der gesamte Datensatz angezeigt, sondern nur die ersten zehn Zeilen. Wir sehen außerdem, aus wie vielen Zeilen und Spalten die tibble besteht und welcher Objektklasse die einzelnen Spalten angehören: vdata ## # A tibble: 2,982 × 10 ## X Y F1 F2 dur V Tense Cons ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 53.0 4.36 313 966 107. % - P ## 2 53.6 3.65 322 2058 86.0 I - T ## 3 55.1 10.4 336 1186 123. Y - K ## 4 53.1 4.75 693 2149 119. E - T ## 5 52.7 6.46 269 2008 196. Y + K ## 6 53.3 4.7 347 931 77.5 Y - P ## 7 54.4 3.6 705 1119 224. A + P ## 8 51.2 7.38 248 2377 145. I + P ## 9 54.6 2.4 385 1935 103 Y - T ## 10 58.4 9.17 288 595 244. O + T ## # ℹ 2,972 more rows ## # ℹ 2 more variables: Rate &lt;chr&gt;, Subj &lt;chr&gt; Die tibble hat vorrangig die Klasse tbl_df, aber zusätzlich noch tbl und data.frame. Wir werden deshalb im Folgenden trotzdem noch von Data Frames sprechen, wenn wir genau genommen eine tibble meinen. vdata %&gt;% class() ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Natürlich können Sie eine tibble auch selbst erstellen, indem Sie die Funktion tibble() anstelle der Funktion data.frame() verwenden, zum Beispiel so: tibble(x = 1:5, y = 6:10) ## # A tibble: 5 × 2 ## x y ## &lt;int&gt; &lt;int&gt; ## 1 1 6 ## 2 2 7 ## 3 3 8 ## 4 4 9 ## 5 5 10 Wenn Sie die Import-Funktion read_delim() aus dem tidyverse-Package readr anstelle der read.table() Funktion verwenden, wird der Datensatz automatisch als tibble geladen: int &lt;- read_delim(file.path(url, &quot;intdauer.txt&quot;), delim = &quot; &quot;, col_names = c(&quot;idx&quot;, &quot;Vpn&quot;, &quot;dB&quot;, &quot;Dauer&quot;), skip = 1) ## Rows: 15 Columns: 4 ## ── Column specification ─────────────────────────────── ## Delimiter: &quot; &quot; ## chr (1): Vpn ## dbl (3): idx, dB, Dauer ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. int ## # A tibble: 15 × 4 ## idx Vpn dB Dauer ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 S1 24.5 162 ## 2 2 S2 32.5 120 ## 3 3 S2 38.0 223 ## 4 4 S2 28.4 131 ## 5 5 S1 23.5 67 ## 6 6 S2 37.8 169 ## 7 7 S2 30.1 81 ## 8 8 S1 24.5 192 ## 9 9 S1 21.4 116 ## 10 10 S2 25.6 55 ## 11 11 S1 40.2 252 ## 12 12 S1 44.3 232 ## 13 13 S1 26.6 144 ## 14 14 S1 20.9 103 ## 15 15 S2 26.0 212 read_delim() gibt Ihnen auch die Objektklasse für jede Spalte in der Column specification aus. Die Import-Funktionen aus readr sind etwas empfindlicher als die Standard-Funktionen in R. Hier mussten wir zum Beispiel einige Argumente spezifieren (delim, col_names und skip), um damit umzugehen, dass der Data Frame Zeilenindizes enthält. Die Standard-Funktion read.table() kommt hingegen meist damit klar, dass man nur den Pfad zum Datensatz angibt. Weiterführende Infos: Tibbles und readr Wenn Sie mehr über die tibble erfahren möchten, empfehlen wir Kapitel 10 aus R for Data Science. Das Paket readr stellt noch weitere Funktionen zum Laden und Abspeichern von Datensätzen bereit, je nachdem wie die Spalten getrennt werden: read_csv(): comma separated values, d.h. durch Komma getrennte Spalten read_csv2(): durch Semikolon getrennte Spalten read_tsv(): durch Tab getrennte Spalten read_delim(): für alle Trennzeichen geeignet All dies und mehr finden Sie auch in Kapitel 11 aus R for Data Science. 8.2 Pivoting Wenn wir unsere Daten geladen haben, fangen wir mit dem Aufräumen an. Das Ziel ist entweder, dass die Daten so strukturiert sind, dass jede Zeile eine neue Beobachtung enthält und dass die Spalten jeweils eine Variable enthalten. Das Ziel kann auch sein, dass die Daten so strukturiert sind, dass sie unserem Zweck dienen (z.B. dem Erstellen einer Abbildung). tidyr nennt diesen Prozess pivoting und es gibt eine gut erklärte Vignette zu dem Thema: vignette(&quot;pivot&quot;) Oben haben wir den Data Frame avokal geladen und haben festgestellt, dass die Spalten schnell und langsam eigentlich zwei Ausprägungen der Variable Tempo sind. Das heißt, es wäre besser, eine Spalte namens Tempo (Werte: “schnell”, “langsam”) und eine namens Dauer (Werte aus schnell und langsam in Millisekunden) zu haben: avokal %&gt;% pivot_longer(cols = c(schnell, langsam), names_to = &quot;Tempo&quot;, values_to = &quot;Dauer&quot;) ## # A tibble: 20 × 3 ## Vpn Tempo Dauer ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 S1 schnell 430 ## 2 S1 langsam 415 ## 3 S2 schnell 266 ## 4 S2 langsam 238 ## 5 S3 schnell 567 ## 6 S3 langsam 390 ## 7 S4 schnell 531 ## 8 S4 langsam 410 ## 9 S5 schnell 707 ## 10 S5 langsam 605 ## 11 S6 schnell 716 ## 12 S6 langsam 609 ## 13 S7 schnell 651 ## 14 S7 langsam 632 ## 15 S8 schnell 589 ## 16 S8 langsam 523 ## 17 S9 schnell 469 ## 18 S9 langsam 411 ## 19 S10 schnell 723 ## 20 S10 langsam 612 Der Befehl pivot_longer() wandelt den Data Frame in das so genannte “lange Format” um. Am wichtigsten sind die folgenden drei Argumente: cols: alle Spalten, die umwandelt werden sollen values_to: der Name der neuen Spalte mit den Werten names_to: der Name der neuen Spalte mit den ehemaligen Spaltennamen Die Pivoting-Funktionen von tidyr sind sehr mächtig und können auch deutlich kompliziertere Operationen durchführen. Nehmen wir den Data Frame billboard, der automatisch mit dem tidyverse geladen wird und die Rankings der Billboard Charts aus dem Jahr 2000 enthält: billboard ## # A tibble: 317 × 79 ## artist track date.entered wk1 wk2 wk3 wk4 ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Pac Baby… 2000-02-26 87 82 72 77 ## 2 2Ge+her The … 2000-09-02 91 87 92 NA ## 3 3 Doors … Kryp… 2000-04-08 81 70 68 67 ## 4 3 Doors … Loser 2000-10-21 76 76 72 69 ## 5 504 Boyz Wobb… 2000-04-15 57 34 25 17 ## 6 98^0 Give… 2000-08-19 51 39 34 26 ## 7 A*Teens Danc… 2000-07-08 97 97 96 95 ## 8 Aaliyah I Do… 2000-01-29 84 62 51 41 ## 9 Aaliyah Try … 2000-03-18 59 53 38 28 ## 10 Adams, Y… Open… 2000-08-26 76 76 74 69 ## # ℹ 307 more rows ## # ℹ 72 more variables: wk5 &lt;dbl&gt;, wk6 &lt;dbl&gt;, ## # wk7 &lt;dbl&gt;, wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, ## # wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, ## # wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, ## # wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, ## # wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, … Auch hier ist es der Fall, dass die Spalten wk1, wk2, wk3 usw. eigentlich Levels oder Ausprägungen der Variable week sind. Wir möchten also eine Spalte erstellen, die uns die Woche angibt, und eine Spalte, die den Rank in den Billboard Charts enthält. Um dies zu erreichen, nehmen wir alle Spalten, die mit “wk” beginnen, packen die Spaltennamen in eine neue Spalte namens week und die Werte aus den Spalten in die neue Spalte rank. Das Präfix “wk” aus den alten Spaltennamen können wir durch das Argument names_prefix ablegen. Und zuletzt löschen wir alle NA-Werte (NA steht für not available) – es gibt z.B. keine Zeile für Woche 8 für 2Pac’s “Baby Don’t Cry”, weil der Song in der achten Kalenderwoche nicht in den Top 100 gerankt wurde. billboard %&gt;% pivot_longer(cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, names_prefix = &quot;wk&quot;, values_drop_na = TRUE) ## # A tibble: 5,307 × 5 ## artist track date.entered week rank ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 1 87 ## 2 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 2 82 ## 3 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 3 72 ## 4 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 4 77 ## 5 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 5 87 ## 6 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 6 94 ## 7 2 Pac Baby Don&#39;t Cry (Ke… 2000-02-26 7 99 ## 8 2Ge+her The Hardest Part O… 2000-09-02 1 91 ## 9 2Ge+her The Hardest Part O… 2000-09-02 2 87 ## 10 2Ge+her The Hardest Part O… 2000-09-02 3 92 ## # ℹ 5,297 more rows Es gibt noch ein Gegenstück zu pivot_longer(), nämlich pivot_wider(). Diese Funktion wird deutlich seltener gebraucht, und bekommt vor allem die Argumente: names_from: die Spalte, deren einzigartige Werte als neue Spalten benutzt werden sollen values_from: die Spalte, deren Werte die neuen Spalten füllen sollen Ein Beispiel dafür kann aus dem Data Frame us_rent_income abgeleitet werden, der ebenfalls mit dem tidyverse geladen wird: us_rent_income ## # A tibble: 104 × 5 ## GEOID NAME variable estimate moe ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama income 24476 136 ## 2 01 Alabama rent 747 3 ## 3 02 Alaska income 32940 508 ## 4 02 Alaska rent 1200 13 ## 5 04 Arizona income 27517 148 ## 6 04 Arizona rent 972 4 ## 7 05 Arkansas income 23789 165 ## 8 05 Arkansas rent 709 5 ## 9 06 California income 29454 109 ## 10 06 California rent 1358 3 ## # ℹ 94 more rows Wir möchten eine Spalte income und eine Spalte rent aus den Levels der Spalte variable erstellen und die neuen Spalten dann mit den Werten aus estimate füllen. us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = estimate) ## # A tibble: 104 × 5 ## GEOID NAME moe income rent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama 136 24476 NA ## 2 01 Alabama 3 NA 747 ## 3 02 Alaska 508 32940 NA ## 4 02 Alaska 13 NA 1200 ## 5 04 Arizona 148 27517 NA ## 6 04 Arizona 4 NA 972 ## 7 05 Arkansas 165 23789 NA ## 8 05 Arkansas 5 NA 709 ## 9 06 California 109 29454 NA ## 10 06 California 3 NA 1358 ## # ℹ 94 more rows Im Ergebnis sehen wir jetzt aber einige NA-Werte. Diese können wir zum Beispiel durch Nullen ersetzen, indem wir zusätzlich das Argument values_fill verwenden. us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = estimate, values_fill = 0) ## # A tibble: 104 × 5 ## GEOID NAME moe income rent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama 136 24476 0 ## 2 01 Alabama 3 0 747 ## 3 02 Alaska 508 32940 0 ## 4 02 Alaska 13 0 1200 ## 5 04 Arizona 148 27517 0 ## 6 04 Arizona 4 0 972 ## 7 05 Arkansas 165 23789 0 ## 8 05 Arkansas 5 0 709 ## 9 06 California 109 29454 0 ## 10 06 California 3 0 1358 ## # ℹ 94 more rows Auch hier gibt es wieder komplexere Operationen, die pivot_wider() durchführen kann. Die beiden Hauptargumente names_from und values_from können jeweils auch mehr als eine Spalte angegeben bekommen. pivot_wider() erstellt dann so viele neue Spalten, wie es Kombinationen zwischen den Levels aus den originalen Spalten bzw. Spaltennamen gibt. Hier geben wir zum Beispiel die Spalten estimate und moe bei values_from an und erhalten so in Kombination mit den zwei Levels aus variable vier neue Spalten: us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe)) ## # A tibble: 52 × 6 ## GEOID NAME estimate_income estimate_rent moe_income ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alab… 24476 747 136 ## 2 02 Alas… 32940 1200 508 ## 3 04 Ariz… 27517 972 148 ## 4 05 Arka… 23789 709 165 ## 5 06 Cali… 29454 1358 109 ## 6 08 Colo… 32401 1125 109 ## 7 09 Conn… 35326 1123 195 ## 8 10 Dela… 31560 1076 247 ## 9 11 Dist… 43198 1424 681 ## 10 12 Flor… 25952 1077 70 ## # ℹ 42 more rows ## # ℹ 1 more variable: moe_rent &lt;dbl&gt; Zuletzt noch ein phonetisches Beispiel: Wir möchten aus den Levels der Spalte Bet (Betonung) des Data Frames asp neue Spalten machen und diese mit den Dauerwerten d füllen. Der Code wirft aber eine Warnmeldung, weil es mehrere Werte pro Zelle gibt in den neuen Spalten gibt, wie Sie an der seltsamen Schreibweise sehen können: asp %&gt;% pivot_wider(names_from = Bet, values_from = d) ## Warning: Values from `d` are not uniquely identified; output ## will contain list-cols. ## • Use `values_fn = list` to suppress this warning. ## • Use `values_fn = {summary_fun}` to summarise ## duplicates. ## • Use the following dplyr code to identify duplicates. ## {data} |&gt; ## dplyr::summarise(n = dplyr::n(), .by = c(Wort, Vpn, ## Kons, Bet)) |&gt; ## dplyr::filter(n &gt; 1L) ## # A tibble: 1,723 × 5 ## Wort Vpn Kons un be ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 Fruehlingswetter k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 2 Gestern k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 3 Montag k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 4 Vater k01 t &lt;dbl [4]&gt; &lt;NULL&gt; ## 5 Tisch k01 t &lt;NULL&gt; &lt;dbl [3]&gt; ## 6 Mutter k01 t &lt;dbl [2]&gt; &lt;NULL&gt; ## 7 konnte k01 k &lt;dbl [2]&gt; &lt;NULL&gt; ## 8 Kaffee k01 k &lt;NULL&gt; &lt;dbl [3]&gt; ## 9 Tassen k01 t &lt;NULL&gt; &lt;dbl [2]&gt; ## 10 Teller k01 t &lt;NULL&gt; &lt;dbl [2]&gt; ## # ℹ 1,713 more rows Netterweise gibt uns die Warnmeldung auch sofort drei Lösungswege an: Wir können das Argument values_fn benutzen, um die Warnung zu unterdrücken, uns anzeigen zu lassen wie viele Werte pro Zelle es gibt, oder mit einer zusammenfassenden Funktion die Werte umformen. Letzteres scheint hier sinnvoll zu sein: Dort, wo es mehrere Werte pro Zelle gibt, lassen wir mit mean() den Durchschnitt berechnen: asp %&gt;% pivot_wider(names_from = Bet, values_from = d, values_fn = mean) ## # A tibble: 1,723 × 5 ## Wort Vpn Kons un be ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Fruehlingswetter k01 t 19.1 NA ## 2 Gestern k01 t 22.4 NA ## 3 Montag k01 t 22.3 NA ## 4 Vater k01 t 25.4 NA ## 5 Tisch k01 t NA 55.8 ## 6 Mutter k01 t 19.3 NA ## 7 konnte k01 k 43.9 NA ## 8 Kaffee k01 k NA 56.1 ## 9 Tassen k01 t NA 49.4 ## 10 Teller k01 t NA 59.4 ## # ℹ 1,713 more rows In keinem unserer pivoting-Beispiele haben wir die Data Frames in ihrer veränderten Form überschrieben (z.B. mittels der Doppelpipe). Die Funktionen pivot_longer() und pivot_wider() kann man auch für temporäre Änderungen benutzen, z.B. wenn man den Data Frame in einer bestimmten Form nur für eine Abbildung braucht: avokal %&gt;% pivot_longer(cols = c(schnell, langsam), names_to = &quot;Tempo&quot;, values_to = &quot;Dauer&quot;) %&gt;% ggplot() + aes(x = Tempo, y = Dauer) + geom_boxplot() 8.3 Separating Unser zweites Beispiel für messy data ist der Data Frame vcv, bei dem zwei Informationen in der Spalte Context vorhanden sind: vcv %&gt;% head ## RT Subject Vowel Lang Left Right Context ## 361 647.5 S209 a AE f h f.h ## 362 617.0 S209 a AE f sh f.sh ## 363 728.5 S209 a AE f sh f.sh ## 364 629.0 S209 a AE f th f.th ## 365 688.5 S209 a AE f th f.th ## 366 602.5 S209 a AE s h s.h Wir möchten den linken und rechten Kontext, die hier durch einen Punkt getrennt werden, in eigenen Spalten haben (wir entfernen zu Demonstrationszwecken die Spalten Left und Right, denn die enthalten schon die gewünschte Lösung). vcv %&lt;&gt;% select(RT:Lang, Context) %&gt;% as_tibble() Um unser Ziel zu erreichen, nutzen wir die Funktion separate(), die obligatorisch folgende Argumente bekommt: col: die Spalte, deren Inhalt aufgeteilt werden soll into: die neuen Spaltennamen sep: wie die strings in der gewählten Spalte getrennt werden sollen Die ersten zwei Argumente sind eigentlich klar: col ist die Spalte Context, und bei into geben wir die zwei gewünschten Spaltennamen Left und Right an. Für sep gibt es zwei Optionen: Die erste Möglichkeit ist mittels einer Zahl, die den Index angibt, ab dem getrennt werden soll: wenn z.B. die ersten zwei Buchstaben immer in die eine und der Rest in die zweite Spalte geschrieben werden soll, nutzen wir sep = 2. Wenn wir uns aber die unterschiedlichen Werte in Context anschauen, ist das hier nicht sinnvoll: levels(vcv$Context) ## NULL Der linke Kontext kann aus einem oder zwei Buchstaben bestehen; außerdem ist da noch ein Punkt, der dann entweder in den linken oder rechten Kontext übernommen werden würde, wie man hier sieht: vcv %&gt;% separate(col = Context, into = c(&quot;Left&quot;, &quot;Right&quot;), sep = 1) ## # A tibble: 810 × 6 ## RT Subject Vowel Lang Left Right ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f .h ## 2 617 S209 a AE f .sh ## 3 728. S209 a AE f .sh ## 4 629 S209 a AE f .th ## 5 688. S209 a AE f .th ## 6 602. S209 a AE s .h ## 7 632. S209 a AE s .sh ## 8 574 S209 a AE s .th ## 9 719 S209 a AE s .h ## 10 569 S209 a AE s .th ## # ℹ 800 more rows vcv %&gt;% separate(col = Context, into = c(&quot;Left&quot;, &quot;Right&quot;), sep = 2) ## # A tibble: 810 × 6 ## RT Subject Vowel Lang Left Right ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f. h ## 2 617 S209 a AE f. sh ## 3 728. S209 a AE f. sh ## 4 629 S209 a AE f. th ## 5 688. S209 a AE f. th ## 6 602. S209 a AE s. h ## 7 632. S209 a AE s. sh ## 8 574 S209 a AE s. th ## 9 719 S209 a AE s. h ## 10 569 S209 a AE s. th ## # ℹ 800 more rows Die andere Möglichkeit ist eine regular expression (auch: regulärer Ausdruck oder RegEx). Dafür gibt man ein Muster (pattern) an, nach dem die Trennung in zwei Spalten erfolgen soll. Das würde für unser Beispiel gut passen, weil wir immer am Punkt trennen wollen. Der Punkt steht aber leider bei den regulären Ausdrücken für ein (und zwar egal welches) Schriftzeichen. Wenn wir den Punkt als Punkt verwenden wollen müssen wir ihn durch das Escape-Zeichen, den doppelten Backslash, schützen. vcv %&gt;% separate(col = Context, into = c(&quot;Left&quot;, &quot;Right&quot;), sep = &quot;\\\\.&quot;) ## # A tibble: 810 × 6 ## RT Subject Vowel Lang Left Right ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f h ## 2 617 S209 a AE f sh ## 3 728. S209 a AE f sh ## 4 629 S209 a AE f th ## 5 688. S209 a AE f th ## 6 602. S209 a AE s h ## 7 632. S209 a AE s sh ## 8 574 S209 a AE s th ## 9 719 S209 a AE s h ## 10 569 S209 a AE s th ## # ℹ 800 more rows So erreichen wir also das Ziel, dass jede Spalte nur eine Variable enthält! Weiterführende Infos: reguläre Ausdrücke RegExps sind ein komplexes Thema, in das wir hier nicht tiefer einsteigen werden. Wenn Sie sich einlesen wollen, empfehlen wir Kapitel 14 aus R for Data Science. "],["joining-mit-dplyr.html", "9 Joining mit dplyr 9.1 Mutating Joins 9.2 Filtering Joins", " 9 Joining mit dplyr Laden Sie die folgenden Packages un Data Frames: library(tidyverse) library(magrittr) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; vcv &lt;- read.table(file.path(url, &quot;vcvC.txt&quot;)) Vielleicht kennen Sie von der Arbeit mit relationalen Daten(banken) und/oder SQL den sogenannten join. Das Prinzip relationaler Daten beruht darauf, alle Informationen und Messwerte, die man gesammelt und erhoben hat, in thematisch sinnvoll aufgeteilten Tabellen abzuspeichern. So könnte man nach einem Experiment zum Beispiel eine Tabelle mit den Messwerten (Formantwerte, Grundfrequenz, etc.) und eine Tabelle mit den Metadaten (Alter, Herkunft, Bildungsstand, etc.) zu den Sprechern erstellen. Zusätzlich bietet es sich vielleicht an, eine Tabelle mit Informationen über das erhobene Material (Wörter, Betonung, Phoneme, Stimuli, etc.) und über die getesteten Bedingungen (Sprechtempo, welcher Gesprächspartner, etc.) zu haben. Wenn nötig, kann man jederzeit (und ggf. nur temporär) zwei Tabellen über einen key, d.h. eine Identifikationsspalte, miteinander verbinden. Bei dplyr unterscheiden wir zwischen mutating joins und filtering joins. 9.1 Mutating Joins Wie auch bei mutate() werden einem Data Frame x durch einen mutating join weitere Spalten hinzugefügt. Im Gegensatz zu mutate() stammen die neuen Spalten aber aus einem anderen Data Frame y. In beiden Data Frames x und y muss es mindestens eine Spalte geben, die einen identifier oder key enthält, über den die Tabellen verbunden werden können. 9.1.1 Inner Join Die einfachste Form des mutating join ist der sogenannte inner join, der mittels der Funktion inner_join() durchgeführt wird. Die Funktion bekommt als Argumente zwei Data Frames x und y und den Identifier im Argument by. Das Ergebnis eines inner join enthält alle Spalten von x und y sowie alle Zeilen, für die es einen Match in beiden Data Frames gibt. Fehlende Werte (NA) tauchen nicht im Ergebnis eines inner join auf, daher ist hier immer Vorsicht angebracht. Als einfaches Beispiel verwenden wir hier eine Tabelle mit Grundfrequenzwerten von zehn Sprechern und eine Tabelle mit Metadaten über die zehn Sprecher: measures &lt;- tibble(subject = rep(paste0(&quot;s&quot;, 1:10), each = 10), F0 = rnorm(100, 120, 15)) measures ## # A tibble: 100 × 2 ## subject F0 ## &lt;chr&gt; &lt;dbl&gt; ## 1 s1 124. ## 2 s1 112. ## 3 s1 124. ## 4 s1 109. ## 5 s1 119. ## 6 s1 134. ## 7 s1 136. ## 8 s1 104. ## 9 s1 131. ## 10 s1 99.4 ## # ℹ 90 more rows meta &lt;- tibble(subject = paste0(&quot;s&quot;, 1:10), age = rep(c(&quot;old&quot;, &quot;young&quot;), each = 5)) meta ## # A tibble: 10 × 2 ## subject age ## &lt;chr&gt; &lt;chr&gt; ## 1 s1 old ## 2 s2 old ## 3 s3 old ## 4 s4 old ## 5 s5 old ## 6 s6 young ## 7 s7 young ## 8 s8 young ## 9 s9 young ## 10 s10 young Beide tibbles haben die Spalte subject, die wir als key bei unserem inner join benutzen werden: inner_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 100 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 124. old ## 2 s1 112. old ## 3 s1 124. old ## 4 s1 109. old ## 5 s1 119. old ## 6 s1 134. old ## 7 s1 136. old ## 8 s1 104. old ## 9 s1 131. old ## 10 s1 99.4 old ## # ℹ 90 more rows Es kann vorkommen, dass die key-Spalte in den zwei Data Frames unterschiedlich benannt ist. In diesem Fall sagen wir der Funktion mittels by = c(\"a\"=\"b\"), dass die Spalte a aus dem Data Frame x mit der Spalte b aus dem Data Frame y gematched werden soll (das gilt für alle join Funktionen): measures %&lt;&gt;% rename(Vpn = subject) inner_join(x = measures, y = meta, by = c(&quot;Vpn&quot;=&quot;subject&quot;)) ## # A tibble: 100 × 3 ## Vpn F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 124. old ## 2 s1 112. old ## 3 s1 124. old ## 4 s1 109. old ## 5 s1 119. old ## 6 s1 134. old ## 7 s1 136. old ## 8 s1 104. old ## 9 s1 131. old ## 10 s1 99.4 old ## # ℹ 90 more rows measures %&lt;&gt;% rename(subject = Vpn) In diesem Beispiel werden bislang immer alle Zeilen von measures zurückgegeben und alle Spalten beider Data Frames. Das liegt daran, dass es sowohl in measures als auch in meta Informationen zu denselben zehn Probanden gibt. Wenn wir in einem der Data Frames mehr oder weniger Informationen haben, werden plötzlich Zeilen weggelassen. # Messwerte von 20 statt 10 Sprechern: measures &lt;- tibble(subject = rep(paste0(&quot;s&quot;, 1:20), each = 10), F0 = rnorm(200, 120, 15)) inner_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 100 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 119. old ## 2 s1 123. old ## 3 s1 117. old ## 4 s1 136. old ## 5 s1 128. old ## 6 s1 118. old ## 7 s1 121. old ## 8 s1 104. old ## 9 s1 170. old ## 10 s1 125. old ## # ℹ 90 more rows In diesem Ergebnis gibt es keine Zeilen für die Sprecher 11 bis 20, weil es zu diesen Sprechern keine Informationen im Data Frame meta gibt! 9.1.2 Outer Join Im Unterschied zum inner join werden beim outer join auch Zeilen mit fehlenden Werten beibehalten. Diese fehlenden Werte werden als NA gekennzeichnet. Die einfachste Version eines outer join ist der full join, bei dem alle Zeilen und alle Spalten aus beiden Data Frames beibehalten werden. Die entsprechende Funktion dazu heißt full_join() (wir frisieren das Ergebnis hier mit slice(), um einen interessanten Teil des Ergebnisses hervorzuheben): full_join(x = measures, y = meta, by = &quot;subject&quot;) %&gt;% slice(95:105) ## # A tibble: 11 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s10 122. young ## 2 s10 155. young ## 3 s10 119. young ## 4 s10 108. young ## 5 s10 120. young ## 6 s10 122. young ## 7 s11 129. &lt;NA&gt; ## 8 s11 106. &lt;NA&gt; ## 9 s11 116. &lt;NA&gt; ## 10 s11 123. &lt;NA&gt; ## 11 s11 116. &lt;NA&gt; Dieses Ergebnis besteht aus 200 Zeilen (wenn wir nicht slice() darauf anwenden) – als wir oben die Funktion inner_join() auf die exakt selben tibbles ausgeführt haben, hatte das Ergebnis nur 100 Zeilen. Das liegt daran, dass full_join() die 100 Zeilen mit den Messwerten der Sprecher 11 bis 20 beibehalten hat, während inner_join() diese Zeilen gelöscht hat, weil es für diese Sprecher keine Informationen aus meta zu holen gab. Beim Ergebnis des full_join() finden sich deshalb NA-Werte in der angehängten Spalte age für die Sprecher 11 bis 20. Wenn Sie nicht alle Zeilen aus beiden Data Frames übernehmen wollen, stehen Ihnen die Funktionen left_join() und right_join() zur Verfügung. Beim left_join() werden alle Zeilen aus Data Frame x und beim right_join() alle Zeilen aus dem Data Frame y übernommen. In unserem Beispiel wollen wir alle Zeilen aus measures erhalten und nur die Altersinformation aus meta hinzufügen: left_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 200 × 3 ## subject F0 age ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 s1 119. old ## 2 s1 123. old ## 3 s1 117. old ## 4 s1 136. old ## 5 s1 128. old ## 6 s1 118. old ## 7 s1 121. old ## 8 s1 104. old ## 9 s1 170. old ## 10 s1 125. old ## # ℹ 190 more rows right_join(x = meta, y = measures, by = &quot;subject&quot;) ## # A tibble: 200 × 3 ## subject age F0 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 s1 old 119. ## 2 s1 old 123. ## 3 s1 old 117. ## 4 s1 old 136. ## 5 s1 old 128. ## 6 s1 old 118. ## 7 s1 old 121. ## 8 s1 old 104. ## 9 s1 old 170. ## 10 s1 old 125. ## # ℹ 190 more rows 9.2 Filtering Joins Die zweite Art von joins in R sind die sogenannten filtering joins, die keine neuen Spalten hinzufügen, sondern nur ausgewählte Zeilen zurückgeben. Hierfür gibt es im tidyverse zwei Funktionen: semi_join(): Gibt alle Beobachtungen des Data Frames x zurück, für die es einen Match im Data Frame y gibt anti_join(): Gibt alle Beobachtungen des Data Frames x zurück, für die es keinen Match im Data Frame y gibt Wir werden diese beiden Funktionen anhand der folgenden Data Frames demonstrieren: vcv %&lt;&gt;% as_tibble() vcv ## # A tibble: 810 × 7 ## RT Subject Vowel Lang Left Right Context ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f h f.h ## 2 617 S209 a AE f sh f.sh ## 3 728. S209 a AE f sh f.sh ## 4 629 S209 a AE f th f.th ## 5 688. S209 a AE f th f.th ## 6 602. S209 a AE s h s.h ## 7 632. S209 a AE s sh s.sh ## 8 574 S209 a AE s th s.th ## 9 719 S209 a AE s h s.h ## 10 569 S209 a AE s th s.th ## # ℹ 800 more rows vcv_summary &lt;- vcv %&gt;% group_by(Subject, Vowel) %&gt;% summarise(mean_rt = mean(RT)) %&gt;% ungroup() %&gt;% slice_max(mean_rt, n = 5) ## `summarise()` has grouped output by &#39;Subject&#39;. You can ## override using the `.groups` argument. vcv_summary ## # A tibble: 5 × 3 ## Subject Vowel mean_rt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 S502 i 1173. ## 2 S502 u 1076. ## 3 S502 a 1000. ## 4 S508 u 816. ## 5 S508 i 780. Der Data Frame vcv_summary enthält also die fünf höchsten durchschnittlichen Reaktionszeiten und welchem Sprecher und Vokal diese Werte zugeordnet sind. Wenn wir jetzt herausfinden wollen, aus welchen Beobachtungen in vcv diese Mittelwerte berechnet wurden, nutzen wir den semi join. Genau genommen möchten wir alle Zeilen aus vcv zurückbekommen, für die es in vcv_summary einen Match bezüglich der Spalten Subject und Vowel gibt. semi_join(x = vcv, y = vcv_summary, by = c(&quot;Subject&quot;, &quot;Vowel&quot;)) ## # A tibble: 75 × 7 ## RT Subject Vowel Lang Left Right Context ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1120. S502 a D f h f.h ## 2 1066. S502 a D f sh f.sh ## 3 848 S502 a D f sh f.sh ## 4 1148. S502 a D f th f.th ## 5 1130 S502 a D f th f.th ## 6 938 S502 a D s h s.h ## 7 1124. S502 a D s sh s.sh ## 8 981 S502 a D s th s.th ## 9 774 S502 a D s h s.h ## 10 1104 S502 a D s th s.th ## # ℹ 65 more rows Das Ergebnis enthält jetzt also alle Beobachtungen, aus denen die gemittelten Reaktionszeiten in vcv_summary berechnet wurden. Wir können das nochmal verdeutlichen, indem wir uns ausgeben lassen, welche einzigartigen Kombinationen von Subject und Vowel es im Ergebnis des semi joins gibt (es sind dieselben fünf Kombinationen wie in vcv_summary): semi_join(x = vcv, y = vcv_summary, by = c(&quot;Subject&quot;, &quot;Vowel&quot;)) %&gt;% select(Subject, Vowel) %&gt;% unique() ## # A tibble: 5 × 2 ## Subject Vowel ## &lt;chr&gt; &lt;chr&gt; ## 1 S502 a ## 2 S502 i ## 3 S502 u ## 4 S508 i ## 5 S508 u Mit dem anti join erhalten wir hingegen alle Beobachtungen, aus denen nicht die gemittelten Reaktionszeiten berechnet wurden, oder mit anderen Worten: alle Beobachtungen aus vcv, für die es bzgl. Subject und Vowel keinen Match in vcv_summary gibt. anti_join(x = vcv, y = vcv_summary, by = c(&quot;Subject&quot;, &quot;Vowel&quot;)) ## # A tibble: 735 × 7 ## RT Subject Vowel Lang Left Right Context ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 648. S209 a AE f h f.h ## 2 617 S209 a AE f sh f.sh ## 3 728. S209 a AE f sh f.sh ## 4 629 S209 a AE f th f.th ## 5 688. S209 a AE f th f.th ## 6 602. S209 a AE s h s.h ## 7 632. S209 a AE s sh s.sh ## 8 574 S209 a AE s th s.th ## 9 719 S209 a AE s h s.h ## 10 569 S209 a AE s th s.th ## # ℹ 725 more rows Anti joins eignen sich unter anderem zur Fehlersuche in den eigenen Daten. Nehmen wir nochmal unsere Beispieldaten von vorhin, measures mit Messwerten für 20 Sprecher, und meta mit Metadaten für nur 10 dieser Sprecher. Wenn wir den anti join hier anwenden, finden wir sofort heraus, für welche Zeilen in measures es keinen Match in meta gibt, für welche Sprecher es also keine Metadaten gibt. anti_join(x = measures, y = meta, by = &quot;subject&quot;) ## # A tibble: 100 × 2 ## subject F0 ## &lt;chr&gt; &lt;dbl&gt; ## 1 s11 129. ## 2 s11 106. ## 3 s11 116. ## 4 s11 123. ## 5 s11 116. ## 6 s11 145. ## 7 s11 90.0 ## 8 s11 133. ## 9 s11 118. ## 10 s11 128. ## # ℹ 90 more rows Das Ergebnis ist das Gegenstück zum inner join von oben: Wir erhalten hier die 100 Beobachtungen für die Sprecher 11 bis 20, für die es keine Metadaten gibt. Weiterführende Infos: dplyr Die joins waren die letzten Funktionen aus dem tidyverse, die wir Ihnen hier vorstellen wollen. Eine Übersicht über alle bisher gelernten und viele weitere Funktionen erhalten Sie in diesem Cheatsheet. "],["pretty-plots.html", "10 Pretty Plots 10.1 Achsenbeschriftungen 10.2 Koordinatensystem begrenzen 10.3 Farben 10.4 Weitere Spezifikationen 10.5 Schriftzeichengröße 10.6 Plots unterteilen und anordnen", " 10 Pretty Plots Laden Sie die folgenden Packages und Data Frames: library(tidyverse) library(magrittr) library(gridExtra) url &lt;- &quot;http://www.phonetik.uni-muenchen.de/~jmh/lehre/Rdf&quot; asp &lt;- read.table(file.path(url, &quot;asp.txt&quot;)) %&gt;% as_tibble() coronal &lt;- read.table(file.path(url, &quot;coronal.txt&quot;)) %&gt;% as_tibble() vdata &lt;- read.table(file.path(url, &quot;vdata.txt&quot;)) %&gt;% as_tibble() int &lt;- read.table(file.path(url, &quot;intdauer.txt&quot;)) %&gt;% as_tibble() ggplot2 bietet Ihnen vielfältige Möglichkeiten, Ihre Abbildungen zu verschönern und zu individualisieren. Hier stellen wir Ihnen die wichtigsten Spezifikationen vor. 10.1 Achsenbeschriftungen Die Beschriftungen der Achsen wird mit xlab() bzw. ylab() erstellt. Einen Titel können Sie mit ggtitle() hinzufügen: ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() + xlab(&quot;Artikulationsstelle&quot;) + ylab(&quot;Dauer (ms)&quot;) + ggtitle(&quot;Boxplot-Daten&quot;) Ansonsten können Sie auch labs() nutzen für alle Labels zusammen: ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar(position = &quot;fill&quot;) + labs(x = &quot;Region&quot;, y = &quot;Proportion&quot;, title = &quot;Proportionale Aufteilung von Frikativen&quot;, subtitle = &quot;Aufgeteilt nach Region&quot;) 10.2 Koordinatensystem begrenzen Um den sichtbaren Bereich eines Plots zu begrenzen oder zu erweitern, können Sie die folgenden Funktionen verwenden. Diese haben jedoch unterschiedliche “Nebenwirkungen” (s. auch hier): xlim() und/oder ylim() bzw. scale_x_continuous(limits = c()) und/oder scale_y_continuous(limits = c()): Eliminiert Datenpunkte beim Heranzoomen und wirft eine Warnmeldung. Dies beeinflusst ggf. Regressionslinien und andere überlagerte Abbildungskomponenten. coord_cartesian(xlim = c(), ylim = c()): Blendet die Datenpunkte nur aus und wirft daher keine Warnmeldung. Dies beeinflusst Regressionslinien und andere überlagerte Abbildungskomponenten nicht. # ohne Achsenbeschränkung: ggplot(int) + aes(x = dB, y = Dauer) + geom_point() # mit coord_cartesian() ggplot(int) + aes(x = dB, y = Dauer) + geom_point() + coord_cartesian(xlim = c(10,40), ylim = c(30,280)) # mit xlim() und ylim() ggplot(int) + aes(x = dB, y = Dauer) + geom_point() + xlim(10, 40) + ylim(30, 280) ## Warning: Removed 2 rows containing missing values or values ## outside the scale range (`geom_point()`). 10.3 Farben ggplot2 verwendet standardmäßig immer dieselbe Farbpalette. Ihnen stehen aber deutlich mehr Farben zur Verfügung, wie Ihnen diese Farbauswahl zeigt. Die Farbnamen bekommen Sie auch mit: colors() # die ersten 10 anzeigen: colors()[1:10] ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; ## [4] &quot;antiquewhite1&quot; &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; ## [7] &quot;antiquewhite4&quot; &quot;aquamarine&quot; &quot;aquamarine1&quot; ## [10] &quot;aquamarine2&quot; Ihre Farbauswahl teilen Sie mit den Argumenten col (Umriss- bzw. Linienfarbe) bzw. fill (Füllfarbe) im aesthetic mapping mit. Wenn wir die Variable Kons in folgendem Boxplot farb-kodieren wollen, sieht das so aus: # mit &quot;fill&quot; (empfohlen für Boxplots!) ggplot(asp) + aes(x = Kons, y = d, fill = Kons) + geom_boxplot() # mit &quot;col&quot; ggplot(asp) + aes(x = Kons, y = d, col = Kons) + geom_boxplot() Wie Sie sehen, wurde diesen zwei Plots automatisch eine Legende hinzugefügt, die aufschlüsselt, welche Farben für welche Werte der Variable Kons verwendet wurden. Jetzt wollen wir unsere Farben selbst auswählen: # &quot;fill&quot; mit eigenen Farben farben &lt;- c(&quot;darkgoldenrod1&quot;, &quot;navy&quot;) ggplot(asp) + aes(y = d, x = Kons, fill = Kons) + geom_boxplot(fill = farben) Hier gibt es keine Legende. Wenn wir bei selbst gewählten Farben eine Legende haben wollen, benutzen wir eine Funktion namens scale_color_manual() bzw. scale_fill_manual(): # &quot;fill&quot; mit eigenen Farben farben &lt;- c(&quot;darkgoldenrod1&quot;, &quot;navy&quot;) ggplot(asp) + aes(y = d, x = Kons, fill = Kons) + geom_boxplot() + scale_fill_manual(values = farben) # dasselbe für den Barplot ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar() + scale_fill_manual(values = farben) Für Boxplots gibt es übrigens die Möglichkeit, die Outlier unabhängig von der Box zu gestalten: farben &lt;- c(&quot;darkgoldenrod1&quot;, &quot;navy&quot;) ggplot(asp) + aes(y = d, x = Kons, fill = Bet) + geom_boxplot(outlier.color = &quot;red&quot;, outlier.shape = 4, outlier.size = 3) + scale_fill_manual(values = farben) 10.4 Weitere Spezifikationen Es gibt natürlich noch deutlich mehr Spezifikationen für die einzelnen Abbildungstypen als die Farbe, z.B. die Zeichengröße, den Linientyp, die Punktform, die Schriftart… col: Umriss- bzw. Linienfarbe fill: Füllfarbe shape: Form size: Größe linewidth: Liniendicke lty: Linientyp stroke: Dicke für Text Dazu gibt es eine Vignette: vignette(&quot;ggplot2-specs&quot;) Einige dieser Spezifikationen wenden wir hier an: ggplot(int) + aes(x = dB, y = Dauer) + geom_point(col = &quot;purple&quot;, size = 3, shape = 0) + geom_line(col = &quot;orange&quot;, size = 1.5, lty = &quot;twodash&quot;) ## Warning: Using `size` aesthetic for lines was deprecated in ## ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see ## where this warning was generated. Sie sollten sich aber natürlich immer sorgfältig überlegen, ob eine Spezifikation notwendig ist, um die Abbildung klarer zu gestalten. 10.5 Schriftzeichengröße Die Default-Schriftzeichengröße der Achsenbeschriftung und Titel ist 11pt oder kleiner. Vor allem wenn Sie Ihre Plots präsentieren, ist es SEHR wichtig, dass Sie die Schriftzeichengröße verändern. Wir empfehlen mind. 16-24pt. Hierfür müssen wir das theme() ändern. ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() + xlab(&quot;Artikulationsstelle&quot;) + ylab(&quot;Dauer (ms)&quot;) + ggtitle(&quot;Boxplot-Daten&quot;) + theme(text = element_text(size = 24), # Beschriftungen &amp; Titel axis.text = element_text(size = 18)) # Achsenbeschriftungen Weiterführende Infos: theme() Das theme() ist z.B. für die Hintergrundfarbe der Plots, die Achsen, und vieles weitere zuständig. Diese Übersicht an Argumenten der Funktion theme() zeigt Ihnen, wie viel Sie damit einstellen können. 10.6 Plots unterteilen und anordnen 10.6.1 Plots unterteilen ggplot2 bietet zwei Möglichkeiten, einen Plot in mehrere zu unterteilen: facet_wrap() und facet_grid(). Hauptargument dieser Funktionen ist/sind die üblicherweise kategoriale(n) Variable(n), deren Werte in getrennten Panels dargestellt werden sollen. Zum Beispiel können wir die Datenpunkte, die mit unterschiedlichen Phonemen assoziiert sind, in getrennten Panels darstellen. Die Formeln, um die Variablen anzugeben, sehen wie folgt aus: .~Var1 bzw. ~Var1 Var1~. (Punkt muss da sein!) Var1~Var2 Var1+Var2~Var3 Var1~Var2+Var3 Es bietet sich nicht an, mehr als drei Variablen in facet_wrap() oder facet_grid() zu verwenden, da dies die Übersichtlichkeit des Plots deutlich einschränkt. facet_wrap() ordnet die Panels eines Plots in Reihen und Spalten an. # aufteilen nach Versuchsperson ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_wrap(~Subj) # aufteilen nach Versuchsperson und Gespanntheit ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_wrap(Subj~Tense) facet_grid() hingegen ordnet in Zeilen oder Spalten. Die Reihenfolge für die Formel ist facet_grid(Zeilen~Spalten) # aufteilen nach Versuchsperson in Zeilen ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_grid(Subj~.) # aufteilen nach Versuchsperson in Spalten ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_grid(~Subj) # aufteilen nach Versuchsperson und Tense ggplot(vdata) + aes(x = F1, y = F2) + geom_point() + facet_grid(Subj~Tense) 10.6.2 Plots anordnen Des Weiteren gibt es die Möglichkeit, mehrere Plots neben- oder untereinander anzuordnen. Hierfür verwenden wir die Funktion grid.arrange() die oben geladene Library gridExtra. plot1 &lt;- ggplot(asp) + aes(x = Kons, y = d) + geom_boxplot() plot2 &lt;- ggplot(coronal) + aes(x = Region, fill = Fr) + geom_bar() plot3 &lt;- ggplot(int) + aes(x = dB, y = Dauer) + geom_line() + geom_point() # in drei Spalten und einer Zeile anordnen grid.arrange(plot1, plot2, plot3, ncol = 3, nrow = 1) # in einer Spalte und drei Zeilen anordnen grid.arrange(plot1, plot2, plot3, ncol = 1, nrow = 3) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
